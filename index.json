[
{
	"uri": "/notes/api_reference/",
	"title": "API Reference",
	"tags": [],
	"description": "",
	"content": "A more formal API Reference can be found on ReadTheDocs.\n"
},
{
	"uri": "/pong/ball/bouncing/library_integration/",
	"title": "Library Integration",
	"tags": [],
	"description": "",
	"content": "So we\u0026rsquo;ve found a library in our target language that implements some feature we want. In our case it\u0026rsquo;s the bump.lua library that provides AABB collision detection.\nNow we need to declare that library to TypeScript so we can use it in our game code.\nIf you\u0026rsquo;d like a very detailed description of declaration files and how they work, I recommend perusing the official documentation. But I will give a specific use-case walkthrough here.\nFirst, let\u0026rsquo;s download bump.lua and place it in the lua-lib folder. This ensures that the library will be included in your game during the build process.\nIn the lua-lib folder, let\u0026rsquo;s create a new file: lua-lib/bump.d.ts\nNow we need to find out which functions of the library we are actually going to use. If we look over the bump.lua documentation, we see that the library asks us to initialize a \u0026ldquo;world\u0026rdquo; using bump.newWorld, add rectangles to the world with world:add, and declare their movements using world:move. We can also use world:check and world:update for finer control over the rectangles.\nFirst things first, the newWorld function.\nexport function newWorld(this: void, cell_size?: number): World;  Why \u0026ldquo;this: void\u0026rdquo;?\nIn Lua, there are two ways to call a function: with the dot . syntax or the colon : syntax. The colon is used as shorthand for functions that need to have the self argument passed to the function being called.\nSince newWorld is called at the library level, \u0026ldquo;this: void\u0026rdquo; tells TypeScriptToLua that this function does not need self and should be called with the dot syntax.\nFor more information, check out the TypeScriptToLua documentation\n We\u0026rsquo;ll need to declare the World interface as well, with its \u0026ldquo;add\u0026rdquo; and \u0026ldquo;move\u0026rdquo; functions.\nexport interface World { add(table: table, x: number, y: number, width: number, height: number): void; /** @tupleReturn */ check(table: table, x: number, y: number, filter?: (item: table, other: table) =\u0026gt; CollisionType): [number, number, Collision[], number]; /** @tupleReturn */ move(table: table, x: number, y: number): [number, number, Collision[], number]; update(table: table, x: number, y: number, width?: number, height?: number): void; remove(table: table): void; }  In Lua, table is our generic object. All of our classes and other objects are translated to tables when using TSTL, so it\u0026rsquo;s a convenient type for generic objects.\n\u0026ldquo;add\u0026rdquo; is a pretty straightforward function: it takes a position and a width and height and adds that rectangle to the World.\n\u0026ldquo;check\u0026rdquo; and \u0026ldquo;move\u0026rdquo; are a bit more involved. See the return type there? That means that the function returns multiple variables. This is called a \u0026ldquo;tuple return\u0026rdquo; in Lua. @tupleReturn tells the TSTL transpiler that the function returns a tuple so it can translate the call directly. We\u0026rsquo;ll talk more about this in a second.\n\u0026ldquo;check\u0026rdquo; and \u0026ldquo;move\u0026rdquo; return four variables. The first two are actualX and actualY, which are the new positions after the move. The next is cols, which is a list of collisions detected during the move. The final is len, which is the total amount of collisions detected.\n\u0026ldquo;remove\u0026rdquo; takes a table and removes it from the world. This is used when objects are destroyed and no longer exist in the game.\nInspecting the contents of cols in the bump.lua documentation gives us the following types and interfaces:\nexport type CollisionType = \u0026quot;touch\u0026quot; | \u0026quot;cross\u0026quot; | \u0026quot;slide\u0026quot; | \u0026quot;bounce\u0026quot;; export interface Vector { x: number, y: number } export interface Rect { x: number, y: number, w: number, h: number } export interface Collision { item: table, other: table, type: CollisionType, overlaps: boolean, ti: number, move: Vector, normal: Vector, touch: Vector, itemRect: Rect, otherRect: Rect }  Finally, \u0026ldquo;update\u0026rdquo; tells the World about the new position of an object. It\u0026rsquo;s useful if we are using \u0026ldquo;check\u0026rdquo; instead of \u0026ldquo;move\u0026rdquo;.\nWith that out of the way, we can integrate the collision detection functionality into our project.\n"
},
{
	"uri": "/pong/move_paddle/motion_engine/",
	"title": "Motion Engine",
	"tags": [],
	"description": "",
	"content": "To create an Engine, we extend the Engine class.\nCreate a file: game/engines/motion.ts\nimport { Engine } from \u0026quot;encompass-ecs\u0026quot;; export class MotionEngine extends Engine { public update(dt: number) {} }  Every Engine needs an update method, which optionally takes a delta-time value as a parameter.\ndelta-time is simply the time that has elapsed between the last frame and the current one in seconds. We\u0026rsquo;ll talk more about why this is important in a minute.\nLet\u0026rsquo;s think for a minute about what we want this Engine to actually do. Motion is just the change of position over time, right? So our MotionEngine is going to modify PositionComponents based on some amount of movement.\nWe\u0026rsquo;re gonna need a Message. More specifically, a ComponentMessage.\nCreate a file: game/messages/component/motion.ts\nimport { ComponentMessage, Message } from \u0026quot;encompass-ecs\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; export class MotionMessage extends Message implements ComponentMessage { public component: Readonly\u0026lt;PositionComponent\u0026gt;; public x: number; public y: number; }  implements means that the class defines certain required properties or methods. If you don\u0026rsquo;t understand it right now, don\u0026rsquo;t worry, just know that in this case, a Message that implements ComponentMessage needs to have a component property. In our case, a MotionMessage wants to refer to some specific PositionComponent that needs to be updated.\nWarning\nWhy is the component type wrapped in Readonly? You can actually get away with not doing this, but it means you can accidentally get around some of the safety features of Encompass that prevent race conditions. So make sure you do this when defining a ComponentMessage.\n Tip\nRemember before when I said that it is a big no-no to have Components reference each other? Well, it\u0026rsquo;s perfectly fine to have Messages refer to a Component, or even multiple Components.\nDon\u0026rsquo;t ever have a Message that refers to another Message though. That is very bad.\n Now, how is our MotionEngine going to interact with MotionMessages? It\u0026rsquo;s going to Read them.\nimport { Engine, Reads } from \u0026quot;encompass-ecs\u0026quot;; import { MotionMessage } from \u0026quot;game/messages/component/motion\u0026quot;; @Reads(MotionMessage) export class MotionEngine extends Engine { public update(dt: number) { const motion_messages = this.read_messages(MotionMessage); } }  What happens if we don\u0026rsquo;t declare @Reads but still call read_messages? Encompass will yell at us when the game runs, because then it can\u0026rsquo;t guarantee that this Engine runs after Engines which emit MotionMessages, which is no good. We\u0026rsquo;ll talk about Emitting messages soon.\nNow we have a reference to all MotionMessages that were emitted this frame. Let\u0026rsquo;s use them to update PositionComponents.\nimport { Engine, Reads } from \u0026quot;encompass-ecs\u0026quot;; import { MotionMessage } from \u0026quot;game/messages/component/motion\u0026quot;; @Reads(MotionMessage) export class MotionEngine extends Engine { public update(dt: number) { const motion_messages = this.read_messages(MotionMessage); for (const message of motion_messages.values()) { const position_component = message.component; position_component.x += message.x; position_component.y += message.y; } } }  Uh oh. The compiler is yelling at us. \u0026ldquo;Cannot assign to \u0026lsquo;x\u0026rsquo; because it is a read-only property.\u0026rdquo; We\u0026rsquo;re going to need to make the component Mutable.\nMutable is a scary word, but it really just means \u0026ldquo;can have its properties changed.\u0026rdquo; We really don\u0026rsquo;t want two different Engines to be able to change the same Component type, because then we can\u0026rsquo;t be certain about what the final result of the changes will be, and that is an opportunity for horrible nasty bugs to lurk in our game.\nSo if we\u0026rsquo;re going to be changing PositionComponents, the Engine needs to declare that it Mutates them, and then make the Component mutable.\nimport { Engine, Mutates, Reads } from \u0026quot;encompass-ecs\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; import { MotionMessage } from \u0026quot;game/messages/component/motion\u0026quot;; @Reads(MotionMessage) @Mutates(PositionComponent) export class MotionEngine extends Engine { public update(dt: number) { const motion_messages = this.read_messages(MotionMessage); for (const message of motion_messages.values()) { const position_component = this.make_mutable(message.component); position_component.x += message.x; position_component.y += message.y; } } }  Now the compiler is content, and so are we.\nLet\u0026rsquo;s add this Engine to our WorldBuilder before we forget.\nIn game/game.ts\n... public load() { this.canvas = love.graphics.newCanvas(); const world_builder = new WorldBuilder(); // ADD YOUR ENGINES HERE... world_builder.add_engine(MotionEngine); ... }  Of course, if we run the game now, nothing will happen, because nothing is actually sending out MotionMessages. Let\u0026rsquo;s make that happen.\n"
},
{
	"uri": "/pong/draw_paddle/canvas_component/",
	"title": "Canvas Component",
	"tags": [],
	"description": "",
	"content": "LOVE provides a neat little drawing feature called Canvases. You can tell LOVE to draw to a Canvas instead of the screen, and then save the Canvas so you don\u0026rsquo;t have to repeat lots of draw procedures. It\u0026rsquo;s very nifty.\nLet\u0026rsquo;s set up a CanvasComponent. To create a new Component type, we extend the Component class.\nCreate a file: game/components/canvas.ts\nimport { DrawComponent } from \u0026quot;encompass-ecs\u0026quot;; export class CanvasComponent extends DrawComponent { public canvas: Canvas; public x_scale: number; public y_scale: number; }  Let\u0026rsquo;s break this down a bit. What\u0026rsquo;s a DrawComponent? A DrawComponent is a subtype of Component that includes a layer property, which is used for rendering.\nimport means that we are taking the definition of DrawComponent from another file, in this case the Encompass library. export means that we want this class to be available to other files in our project. If we don\u0026rsquo;t export this class, it won\u0026rsquo;t be very useful to us, so let\u0026rsquo;s make sure to do that.\nWe provide some extra information, x_scale and y_scale so we can shrink or stretch the Canvas if we want to.\nYou might be wondering - how does TypeScript know about things like Canvas, which are defined in LOVE? LOVE uses Lua, not TypeScript.\nThe answer is a thing called definition files. Definition files let TypeScript know about things that exist in the target environment. You don\u0026rsquo;t really need to understand how it works just now, just know that the Encompass/LOVE starter pack depends on the lovely love-typescript-definitions project.\n When we actually use the CanvasComponent, we will attach a Canvas that has stuff drawn on it. We\u0026rsquo;ll get to that in a minute.\nThat\u0026rsquo;s it for our CanvasComponent. We need one more bit of information before we can write our Renderer.\n"
},
{
	"uri": "/pong/introduction/",
	"title": "Intro",
	"tags": [],
	"description": "",
	"content": "Everyone has played, or at least heard of, Pong. Right? Right\u0026hellip;\nPong was one of the first video games ever created and as such, it is extremely simple. We\u0026rsquo;re introducing a lot of new concepts with Encompass and the Hyper ECS architecture, so I think it\u0026rsquo;s a good choice to try re-implementing this game in Encompass as an example.\nWe\u0026rsquo;ll be developing this with the Encompass/LOVE starter pack. Go ahead and set that up if you haven\u0026rsquo;t already so you can follow along. And please do follow along - you can do it!\nTip\nI recommend following along with the tutorial by actually typing out the code rather than cut-and-pasting. You\u0026rsquo;ll be able to follow the structure of what\u0026rsquo;s happening much better. Think of it like taking notes.\n If at any point you become confused in the tutorial, feel free to ask questions in our Discord server or file an issue report on our GitHub Issues page. You can also take a look at the exact tutorial code in the GitHub repo.\n"
},
{
	"uri": "/concepts/component/",
	"title": "Component",
	"tags": [],
	"description": "",
	"content": "A Component is a collection of related data.\nTo define a Component, extend the Component class.\nimport { Component } from \u0026quot;encompass-ecs\u0026quot;; class PositionComponent extends Component { public x: number; public y: number; }  Components are created in context with an Entity.\nconst entity = World.create_entity(); const position = entity.add_component(PositionComponent); position.x = 3; position.y = -4;  Components cannot exist apart from an Entity and are automagically destroyed when they are removed or their Entity is destroyed.\nWarning\nComponents should never reference other Components. This breaks the principle of loose coupling. You will regret it if you do this.\n "
},
{
	"uri": "/getting_started/choosing/",
	"title": "Choosing An Engine",
	"tags": [],
	"description": "",
	"content": "Encompass is not a game engine.\nIt does not provide any tools for drawing graphics to the screen, playing sounds, handling inputs, or anything of the sort.\nEncompass is purely a tool for managing the code that handles the simulation aspects of your game.\nThat means it needs to run on top of an engine.\nWhich engine should I use?\nUltimately, this is a question that you have to answer for your project. Is there an engine you\u0026rsquo;re already comfortable with? Which platforms are you targeting? Linux? PS4? Android? Are there any features you would really like to have, like a built-in physics simulator? These are questions that could help you choose an engine.\nEncompass-TS can hook into any engine that supports JavaScript or Lua scripting. Encompass-CS can hook into any engine that supports C# scripting. (NOTE: Encompass-CS is in early alpha.)\nSo you have a lot of choices!\nHere are some engines that I have used:\nLÖVE is a wonderful little framework for 2D games. It\u0026rsquo;s cross-platform and very lightweight, but with a lot of powerful features, including a complete physics simulator. It uses Lua scripting, so you would want Encompass-TS.\nMonoGame is a cross-platform 2D/3D framework that thousands of games have used. You can use it to ship games on basically any platform that exists and it is extremely well-supported. It uses C# scripting so you would want Encompass-CS.\nBabylonJS uses the power of WebGL to run 3D games in the browser. It has a powerful graphics pipeline and you can make stuff that has some wow factor. It runs on JS.\nEncompass gives you the power to develop using many different engines, so feel free to experiment and find one you like! And if you switch to an engine that uses the same scripting language, it\u0026rsquo;s actually very easy to switch engines, because the simulation layer is mostly self-contained.\n"
},
{
	"uri": "/why/",
	"title": "Why?",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Why? A question that many of us find ourselves asking when coding a game.\n"
},
{
	"uri": "/concepts/message/",
	"title": "Message",
	"tags": [],
	"description": "",
	"content": "Similar to Components, Messages are collections of data.\nMessages are used to transmit data between Engines so they can manipulate the game state accordingly.\nTo define a message, extend the Message class.\nimport { Message } from \u0026quot;encompass-ecs\u0026quot;; class MotionMessage extends Message { public x: number; public y: number; }  Messages are temporary and destroyed at the end of the frame.\nOk fine, since you asked, Messages actually live in an object pool so that they aren\u0026rsquo;t garbage-collected at runtime. But you as the game developer don\u0026rsquo;t have to worry about that.\n "
},
{
	"uri": "/getting_started/terminal/",
	"title": "The Terminal",
	"tags": [],
	"description": "",
	"content": "Which operating system are you using?\nIf you are on OSX, great! You have an app called Terminal. You can use it to build and run Encompass projects.\nIf you are on Linux, great! You are probably a pretty savvy user, but just in case, you probably have a program called Terminal or Konsole on your machine. You can use it to build and run Encompass projects.\nIf you are on Windows\u0026hellip; things get a bit trickier. The built-in terminals are garbage.\nSeveral people have recommended Cmder to me. I recommend installing the \u0026ldquo;Full\u0026rdquo; version that includes Git for Windows.\nYou can also just install Git For Windows and choose Git Bash when it asks you which terminal you want. It\u0026rsquo;s\u0026hellip; fine.\nIt can be intimidating, but learning to be comfortable with the command line will greatly assist you on your programming journey. You\u0026rsquo;ll get used to it in no time if you practice.\n"
},
{
	"uri": "/getting_started/editor/",
	"title": "The Text Editor",
	"tags": [],
	"description": "",
	"content": "You will want some kind of text editor to develop Encompass projects.\nI highly recommend VSCodium if you are on Windows or OSX, and Code - OSS if you are on Linux. These are open-source distributions of Microsoft\u0026rsquo;s VSCode editor, which features excellent Typescript integration and various convenient features, like an integrated Git interface and terminal. (Make sure you set the terminal to Git Bash if you are on Windows - this is under File -\u0026gt; Settings.)\nOf course, if you prefer some other editor, that will be perfectly fine.\n"
},
{
	"uri": "/notes/acknowledgments/",
	"title": "Acknowledgments",
	"tags": [],
	"description": "",
	"content": "Special thanks is due to Mark Kollasch for his insight into the n-pass engine structure and for overall excellent architecture feedback. Many of the ideas in this project were given to me by him.\nThanks to Seiji Tanaka for writing a state machine system with me many years ago and sending me on a long journey of thinking about game architecture.\nThanks to Mitch Gerrard for doing a bunch of graph theory problems with me.\nThanks to the Glitch City LA community for keeping me alive all these years of making games.\nThanks to the creators and maintainers of LÖVE, a wonderful tool which awakened me to the potential joys of game programming.\nThanks to the developers of TypeScriptToLua, an impressive project which unlocked the power of static typing in LÖVE. Encompass-TS would not have been made without it.\nMy name is Evan Hemsley, and I am a game programmer and digital artist. I hope you make some great projects with Encompass! And if you do, please tell me about them!\n"
},
{
	"uri": "/getting_started/version_control/",
	"title": "Version Control",
	"tags": [],
	"description": "",
	"content": "I strongly recommend using some kind of source control software. It is incredibly foolish to develop without it. Version control lets you make changes to your code without worrying about irreparably ruining your code base, so you can make changes with peace of mind.\nI strongly recommend Git. You\u0026rsquo;ll have to download and install it if you\u0026rsquo;re on Windows.\nThere is an excellent tutorial on how to use Git on the Git website.\nThe basic Git workflow is this: when you make changes, you review them and \u0026ldquo;stage\u0026rdquo; them, and then \u0026ldquo;commit\u0026rdquo; them with a message. Think of a commit as freezing your code at a particular place in time. You can always revert to this exact place once you commit. It\u0026rsquo;s incredibly useful.\nYou can also synchronize your \u0026ldquo;Git repository\u0026rdquo; with a remote server, meaning it will be backed up and centrally accessible. I recommend doing this. GitHub and GitLab both provide free accounts with unlimited private repositories. They will give you instructions for how to create a new repository.\n"
},
{
	"uri": "/pong/polish/paddle_bounce/",
	"title": "Paddle Bounce",
	"tags": [],
	"description": "",
	"content": "One thing that isn\u0026rsquo;t quite right in our game is that when the ball bounces, it reflects directly off the paddle.\nIf we look at the original Pong, we see that the angle of the ball is actually affected by the position where the ball hits the paddle. If the ball hits the edges of the paddle, it bounces off at a wider angle. If it hits the center of the paddle, it bounces horizontally.\nThis is a classic risk/reward mechanic: it\u0026rsquo;s safer to hit the center of the paddle, but it\u0026rsquo;s easier for your opponent to return the shot. It\u0026rsquo;s riskier to hit the edges of the paddle, but the shot is more difficult to return.\nLet\u0026rsquo;s return to our BallPaddleCollisionEngine.\nconst velocity_message = this.emit_component_message(UpdateVelocityMessage, ball_velocity); velocity_message.x_delta = 2 * message.normal.x * Math.abs(ball_velocity.x); velocity_message.y_delta = 2 * message.normal.y * Math.abs(ball_velocity.y);  This is what is reflecting our ball\u0026rsquo;s velocity.\nLet\u0026rsquo;s calculate a new velocity based on where the ball touches the paddle.\nFirst, we don\u0026rsquo;t want the speed of the ball to change. So let\u0026rsquo;s store it. The way we calculate speed is by obtaining the length of the velocity. We also want to know if the ball was travelling right or left at the time of contact.\nconst speed = len(ball_velocity.x, ball_velocity.y); const horizontal = ball_velocity.x \u0026lt; 0 ? 1 : -1;  Now we want to calculate our new angle. First, we want to check how far the point of contact was from the center of the paddle. The problem is that we don\u0026rsquo;t know inside our engine how big the paddle is. Let\u0026rsquo;s fix that.\nLet\u0026rsquo;s return to our PaddleMoveSpeedComponent.\nimport { Component } from \u0026quot;encompass-ecs\u0026quot;; export class PaddleMoveSpeedComponent extends Component { public y: number; }  I think we should just store all of our paddle-related information here, so let\u0026rsquo;s rename it to PaddleComponent, and rename y to move_speed. Make sure to use VSCode\u0026rsquo;s rename feature so you don\u0026rsquo;t have to manually tweak the names in multiple files.\nimport { Component } from \u0026quot;encompass-ecs\u0026quot;; export class PaddleComponent extends Component { public height: number; public move_speed: number; }  Let\u0026rsquo;s change our PaddleSpawner to comply with our changed component.\nconst paddle_component = paddle_entity.add_component(PaddleComponent); paddle_component.move_speed = message.move_speed; paddle_component.height = height;  Now, back in our collision engine, we can get a new rotation. First, we figure out how far the contact was from the center of the paddle. Then we convert that to a number ranging from -1 to 1. Finally, we multiply that number by pi/4 to get a number ranging from -pi/4 to pi/4.\nconst diff = message.touch.y - paddle_y; const scale = diff / (paddle_height * 0.5); const rotation = (scale * math.pi / 4);  Then we perform the rotation on a vector pointing directly to the right, with the same length we calculated earlier. We multiply it to reverse its direction if it was originally travelling to the right.\nlet [new_x_velocity, new_y_velocity] = rotate(rotation, speed, 0); new_x_velocity *= horizontal;  Finally, we create our velocity deltas by subtracting our old velocity from our new desired velocity.\n[ velocity_message.x_delta, velocity_message.y_delta, ] = sub(new_x_velocity, new_y_velocity, ball_velocity.x, ball_velocity.y);  Our final result looks like this:\nimport { Emits, Engine, Reads } from \u0026quot;encompass-ecs\u0026quot;; import { BoundingBoxComponent } from \u0026quot;game/components/bounding_box\u0026quot;; import { PaddleComponent } from \u0026quot;game/components/paddle\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; import { VelocityComponent } from \u0026quot;game/components/velocity\u0026quot;; import { BallPaddleCollisionMessage } from \u0026quot;game/messages/collisions/ball_paddle\u0026quot;; import { UpdatePositionMessage } from \u0026quot;game/messages/update_position\u0026quot;; import { UpdateVelocityMessage } from \u0026quot;game/messages/update_velocity\u0026quot;; import { len, rotate, sub } from \u0026quot;lua-lib/hump/vectorlight\u0026quot;; @Reads(BallPaddleCollisionMessage) @Emits(UpdatePositionMessage, UpdateVelocityMessage) export class BallPaddleCollisionEngine extends Engine { public update() { for (const message of this.read_messages(BallPaddleCollisionMessage).values()) { const ball_position = message.ball_entity.get_component(PositionComponent); const ball_velocity = message.ball_entity.get_component(VelocityComponent); const ball_boundaries = message.ball_entity.get_component(BoundingBoxComponent); const paddle_height = message.paddle_entity.get_component(PaddleComponent).height; const paddle_y = message.paddle_entity.get_component(PositionComponent).y; const velocity_message = this.emit_component_message(UpdateVelocityMessage, ball_velocity); // calculate new ball velocity based on paddle contact const speed = len(ball_velocity.x, ball_velocity.y); const horizontal = ball_velocity.x \u0026lt; 0 ? 1 : -1; const diff = message.touch.y - paddle_y; const scale = diff / (paddle_height * 0.5); const rotation = (scale * math.pi / 4); let [new_x_velocity, new_y_velocity] = rotate(rotation, speed, 0); new_x_velocity *= horizontal; [ velocity_message.x_delta, velocity_message.y_delta, ] = sub(new_x_velocity, new_y_velocity, ball_velocity.x, ball_velocity.y); // calculate bounce position, remembering to re-transform coordinates to origin space const y_distance = Math.abs(message.ball_new_y - (message.touch.y + ball_boundaries.height * 0.5)); const x_distance = Math.abs(message.ball_new_x - (message.touch.x + ball_boundaries.width * 0.5)); const position_message = this.emit_component_message(UpdatePositionMessage, ball_position); position_message.x_delta = 2 * message.normal.x * x_distance; position_message.y_delta = 2 * message.normal.y * y_distance; } } }   Now we have a game on our hands!\n"
},
{
	"uri": "/pong/scoring/goal_collision/",
	"title": "Goal Collision",
	"tags": [],
	"description": "",
	"content": "First we will need a new collision type for goals.\nexport enum CollisionType { ball, goal, paddle, wall, }  And a BallGoalCollisionMessage:\nimport { Entity, Message } from \u0026quot;encompass-ecs\u0026quot;; export class BallGoalCollisionMessage extends Message { public ball_entity: Entity; public goal_entity: Entity; }  And some dispatch logic in the CollisionDispatchEngine:\n... switch (collision_message.collision_type_one) { case CollisionType.ball: switch (collision_message.collision_type_two) { case CollisionType.goal: { const message = this.emit_message(BallGoalCollisionMessage); message.ball_entity = collision_message.entity_one; message.goal_entity = collision_message.entity_two; break; } ...  Don\u0026rsquo;t forget to declare the BallGoalCollisionMessage in @Emits!\nLet\u0026rsquo;s create our BallGoalCollisionEngine:\nimport { Engine, Mutates, Reads } from \u0026quot;encompass-ecs\u0026quot;; import { ScoreComponent } from \u0026quot;game/components/score\u0026quot;; import { BallGoalCollisionMessage } from \u0026quot;game/messages/collisions/ball_goal\u0026quot;; import { World } from \u0026quot;lua-lib/bump\u0026quot;; @Reads(BallGoalCollisionMessage) @Mutates(ScoreComponent) export class BallGoalCollisionEngine extends Engine { private collision_world: World; public initialize(collision_world: World) { this.collision_world = collision_world; } public update() { for (const message of this.read_messages(BallGoalCollisionMessage).values()) { message.ball_entity.destroy(); this.collision_world.remove(message.ball_entity); } } }  When we detect a collision between a ball and a goal, we destroy the ball entity and, importantly, remember to remove its rectangle from the collision world.\nTip\nIt is generally much more performance-efficient to deactivate entities instead of destroying and respawn them, but it\u0026rsquo;s slightly more complicated to do so. In our case, it will be fine to destroy and respawn.\n We\u0026rsquo;ll need a way to create our goal entities now.\nLet\u0026rsquo;s have a new GoalSpawnMessage:\nimport { Message } from \u0026quot;encompass-ecs\u0026quot;; export class GoalSpawnMessage extends Message { public x: number; public y: number; public width: number; public height: number; public player_one: boolean; }  And a new GoalSpawner:\nimport { Spawner } from \u0026quot;encompass-ecs\u0026quot;; import { BoundingBoxComponent } from \u0026quot;game/components/bounding_box\u0026quot;; import { CollisionType, CollisionTypesComponent } from \u0026quot;game/components/collision_types\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; import { ScoreComponent } from \u0026quot;game/components/score\u0026quot;; import { GoalSpawnMessage } from \u0026quot;game/messages/goal_spawn\u0026quot;; import { World } from \u0026quot;lua-lib/bump\u0026quot;; export class GoalSpawner extends Spawner { public spawn_message_type = GoalSpawnMessage; private collision_world: World; public initialize(collision_world: World) { this.collision_world = collision_world; } public spawn(message: GoalSpawnMessage) { const entity = this.create_entity(); const boundaries = entity.add_component(BoundingBoxComponent); boundaries.width = message.width; boundaries.height = message.height; const position = entity.add_component(PositionComponent); position.x = message.x; position.y = message.y; const collision_types_component = entity.add_component(CollisionTypesComponent); collision_types_component.collision_types = [ CollisionType.goal ]; this.collision_world.add( entity, message.x - message.width * 0.5, message.y - message.height * 0.5, message.width, message.height ); } }  Notice this is very similar to our GameBoundarySpawner. I\u0026rsquo;m not thrilled about that, so we could maybe consolidate it later. Let\u0026rsquo;s leave it for now because we\u0026rsquo;re not quite done with this feature.\nNow let\u0026rsquo;s work on a mechanism for respawning the ball.\n"
},
{
	"uri": "/pong/ball/spawning/",
	"title": "Spawning",
	"tags": [],
	"description": "",
	"content": "In game/game.ts\u0026hellip;\nconst ball_entity = world_builder.create_entity(); const ball_position_component = ball_entity.add_component(PositionComponent); ball_position_component.x = 640; ball_position_component.y = 360; const ball_size = 16; const ball_canvas = love.graphics.newCanvas(ball_size, ball_size); love.graphics.setCanvas(ball_canvas); love.graphics.setBlendMode(\u0026quot;alpha\u0026quot;); love.graphics.setColor(1, 1, 1, 1); love.graphics.rectangle(\u0026quot;fill\u0026quot;, 0, 0, ball_size, ball_size); love.graphics.setCanvas(); const ball_canvas_component = ball_entity.add_component(CanvasComponent); ball_canvas_component.canvas = ball_canvas; ball_canvas_component.x_scale = 1; ball_canvas_component.y_scale = 1;  OK. We\u0026rsquo;re both thinking it. Why is all this crap going straight in game.ts? And there\u0026rsquo;s magic values everywhere! You are absolutely right. Encompass actually has a built-in abstraction Engine for creating new Entities called a Spawner. Let\u0026rsquo;s use one.\nLet\u0026rsquo;s create a new folder: game/engines/spawners\nAnd a new file: game/engines/spawners/ball.ts\nimport { Reads, Spawner } from \u0026quot;encompass-ecs\u0026quot;; import { CanvasComponent } from \u0026quot;game/components/canvas\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; import { BallSpawnMessage } from \u0026quot;game/messages/ball_spawn\u0026quot;; @Reads(BallSpawnMessage) export class BallSpawner extends Spawner { public spawn(message: BallSpawnMessage) { const ball_entity = this.create_entity(); const ball_position_component = ball_entity.add_component(PositionComponent); ball_position_component.x = message.x; ball_position_component.y = message.y; const ball_canvas = love.graphics.newCanvas(message.size, message.size); love.graphics.setCanvas(ball_canvas); love.graphics.setBlendMode(\u0026quot;alpha\u0026quot;); love.graphics.setColor(1, 1, 1, 1); love.graphics.rectangle(\u0026quot;fill\u0026quot;, 0, 0, message.size, message.size); love.graphics.setCanvas(); const ball_canvas_component = ball_entity.add_component(CanvasComponent); ball_canvas_component.canvas = ball_canvas; ball_canvas_component.x_scale = 1; ball_canvas_component.y_scale = 1; } }  Spawners aren\u0026rsquo;t very complicated. They have one required method: spawn. The first Message type given to @Reads is assumed to be the spawn message type.\nWhen the Spawner reads a message of the spawn message type, it runs its spawn method once. Simple as that.\nNow let\u0026rsquo;s actually send out the BallSpawnMessage.\nIn game/game.ts\u0026hellip;\n... world_builder.add_engine(BallSpawner); ... const ball_spawn_message = world_builder.emit_message(BallSpawnMessage); ball_spawn_message.x = 640; ball_spawn_message.y = 360; ball_spawn_message.size = 16; ...  Well, it draws, but it\u0026rsquo;s a bit boring without any movement. Let\u0026rsquo;s make it move around.\n"
},
{
	"uri": "/pong/move_paddle/input_handling/",
	"title": "Input Handling",
	"tags": [],
	"description": "",
	"content": "In Pong, the paddles move when the player moves the joystick on their controller up or down.\nWe currently have a MotionEngine that reads MotionMessages and moves the PositionComponents they reference.\nSo\u0026hellip; it makes sense that we would have an InputEngine that sends MotionMessages, yeah?\nCreate a file: game/engines/input.ts\nimport { Engine } from \u0026quot;encompass-ecs\u0026quot;; import { MotionMessage } from \u0026quot;game/messages/component/motion\u0026quot;; export class InputEngine extends Engine { public update() { if (love.keyboard.isDown(\u0026quot;up\u0026quot;)) { this.emit_component_message(MotionMessage, } } }  record scratch\nUh oh. Engine.emit_component_message emits a Component Message, as the name suggests. But it needs an actual component to attach to the message. How do we give the message a reference to our paddle entity\u0026rsquo;s position?\nSounds like we need another Component.\nOne thing we can use Components for is a concept I call marking or tagging. Essentially, we use a Component to designate that an Entity is a certain kind of object in the game.\nCreate a file: component/player_one.ts\nimport { Component } from \u0026quot;encompass-ecs\u0026quot;; export class PlayerOneComponent extends Component {}  That\u0026rsquo;s it! The component itself doesn\u0026rsquo;t need any information on it. Its mere existence on the Entity will tell us that this Entity represents Player 1.\nLet\u0026rsquo;s add it to our paddle Entity.\nIn game/game.ts:\n... paddle_entity.add_component(PlayerOneComponent); ...  Now we can go back to our InputEngine.\nimport { Emits, Engine } from \u0026quot;encompass-ecs\u0026quot;; import { PlayerOneComponent } from \u0026quot;game/components/player_one\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; import { MotionMessage } from \u0026quot;game/messages/component/motion\u0026quot;; @Emits(MotionMessage) export class InputEngine extends Engine { public update() { const player_one_component = this.read_component(PlayerOneComponent); if (player_one_component) { const player_one_entity = this.get_entity(player_one_component.entity_id); if (player_one_entity) { const player_one_position_component = player_one_entity.get_component(PositionComponent); if (love.keyboard.isDown(\u0026quot;up\u0026quot;)) { const message = this.emit_component_message(MotionMessage, player_one_position_component); message.x = 0; message.y = -10; } } } } }  Ok\u0026hellip; what the heck is this.read_component?\nEngines have total freedom to read anything in the game state that they desire. This gives Engines a tremendous amount of flexibility to do what they need to do.\nIn this case, we are reading the game state to find our PlayerOneComponent. From there, we can get the Entity to which the PlayerOneComponent belongs. Then we can get the PositionComponent of that Entity, and send a message about it when the \u0026ldquo;up\u0026rdquo; key is pressed down.\nWarning\nSimilar to Entity.get_component and Entity.get_components, Engines have Engine.read_component and Engine.read_components. If you try to do the singular read_component on a game state that has multiple components of that type, an error will be thrown. So be careful that your singleton components are actually singletons!\n Also, remember when we had to declare @Reads on our MotionEngine? Well, similarly, we have to declare @Emits when our Engine emits a certain kind of Message. Otherwise Encompass will get mad at us and crash the game for our own safety.\nLet\u0026rsquo;s add our InputEngine to the WorldBuilder.\nIn game/game.ts:\n// ADD YOUR ENGINES HERE... world_builder.add_engine(InputEngine); world_builder.add_engine(MotionEngine);  It doesn\u0026rsquo;t matter which order they go in, because remember, Encompass figures it out automatically. I just prefer this order for some reason. Once we have a lot of Engines it stops mattering pretty quickly anyway.\nLet\u0026rsquo;s run the game again!!\n"
},
{
	"uri": "/pong/draw_paddle/position_component/",
	"title": "Position Component",
	"tags": [],
	"description": "",
	"content": "This one is pretty simple. We can\u0026rsquo;t draw something if we don\u0026rsquo;t know where on screen to draw it.\nWell, why didn\u0026rsquo;t we put that in the CanvasComponent? The reason is that position is a concept that is relevant in more situations than just drawing. For example: collision, yeah? So it really needs to be its own component.\nCreate a file: game/components/position.ts\nimport { Component } from \u0026quot;encompass-ecs\u0026quot;; export class PositionComponent extends Component { public x: number; public y: number; }  That\u0026rsquo;s it! Notice that we haven\u0026rsquo;t created a file that is more than 10 lines long yet. I hope you\u0026rsquo;re starting to notice the power of modularity here.\n"
},
{
	"uri": "/pong/draw_paddle/canvas_renderer/",
	"title": "Canvas Renderer",
	"tags": [],
	"description": "",
	"content": "Now that we have a CanvasComponent, we need to tell Encompass how to draw things that have it.\nCreate a file: game/renderers/canvas.ts\nThis is gonna be a bit more complex than our Components, so let\u0026rsquo;s take this slowly.\nimport { Entity, EntityRenderer } from \u0026quot;encompass-ecs\u0026quot;; import { CanvasComponent } from \u0026quot;game/components/canvas\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; @Renders(CanvasComponent, PositionComponent) export class CanvasRenderer extends EntityRenderer { public render(entity: Entity) {} }  An EntityRenderer is defined by the Components it tracks and a render method.\n@Renders is a function called a class decorator. Its first argument should be the DrawComponent, and the subsequent arguments are any number of components that are also required for the EntityRenderer to track an Entity.\nTip\nYou can read more about decorators on the official TypeScript documentation.\n Each time World.draw is called, the EntityRenderer will run its render method on each Entity that it is tracking.\nSo, in our case, we want our CanvasRenderer to render any Entity that has a PositionComponent and a CanvasComponent. Simple as that.\nLet\u0026rsquo;s fill out our render method.\npublic render(entity: Entity) { const position_component = entity.get_component(PositionComponent); const canvas_component = entity.get_component(CanvasComponent); const canvas = canvas_component.canvas; love.graphics.draw( canvas, position_component.x, position_component.y, 0, canvas_component.x_scale, canvas_component.y_scale, canvas.getWidth() * 0.5, canvas.getHeight() * 0.5, ); }  Entity.get_component is a method that gets a Component instance from an Entity when given a Component type. So when we say:\nconst position_component = entity.get_component(PositionComponent);  we are asking the Entity to give us access to its position information.\nOnce we have our specific position and canvas information, we can use that information to tell LOVE to draw something!\nlove.graphics.draw( canvas, position_component.x, position_component.y, 0, canvas_component.x_scale, canvas_component.y_scale, canvas.getWidth() * 0.5, canvas.getHeight() * 0.5, );  This is simply a call to the love.graphics.draw function that LOVE provides. You can read more about it here. We are just telling LOVE to draw our canvas at our PositionComponent\u0026rsquo;s position, with 0 rotation, our scaling factor, and an offset of the canvas\u0026rsquo;s width and height divided by 2. The offset just tells LOVE to draw the canvas starting at the center of the canvas, instead of at the top left corner.\nThat\u0026rsquo;s it! Now we need to set up our World with its starting configuration so our Encompass elements can work in concert.\nClever readers may have noticed something here. Aren\u0026rsquo;t Entities allowed to have any number of Components of a given type? So why is get_component singular?\nWe actually have two different component getter methods: Entity.get_component, and Entity.get_components, which will return a list of all the components of the given type on the Entity.\nIn this case, I am assuming that an Entity will only ever have one PositionComponent, so I am using the get_component method for convenience.\nYou are allowed to make any assumptions about the structure of your Entities as you want - just make sure your assumptions stay consistent, or you will have unpleasant surprises!\n "
},
{
	"uri": "/pong/draw_paddle/",
	"title": "Drawing a Paddle",
	"tags": [],
	"description": "",
	"content": "It\u0026rsquo;s nice to see something on screen right away when we start making a game, so let\u0026rsquo;s make that happen.\nIn a 2D game, Encompass needs to know which order that things should draw in.\nEncompass draws things back to front using integer layers. A negative value means farther in the back. A positive value means farther in the front. So an object on layer 10 will draw on top of an object on layer -10.\nWe\u0026rsquo;ll need two things to get a paddle drawing on screen: A DrawComponent and an EntityRenderer.\nLet\u0026rsquo;s start with the Component.\n"
},
{
	"uri": "/concepts/entity/",
	"title": "Entity",
	"tags": [],
	"description": "",
	"content": "An Entity is a structure composed of a unique ID and a collection of Components.\nEntities do not have any implicit properties or behaviors. They are granted these by their collection of Components.\nThere is no limit to the amount of Components an Entity may have, and Entities can have any number of Components of a particular type.\nEntities are active by default and can be deactivated. They can also be destroyed, permanently removing them and their components from the World.\nEntities are created either by the WorldBuilder or by Engines. (We\u0026rsquo;ll get into these soon.)\nWarning\nYou should never add methods or properties to an Entity. Properties belong on Components and methods belong on Engines.\n "
},
{
	"uri": "/getting_started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Getting Started Let\u0026rsquo;s get you set up to make a game.\n"
},
{
	"uri": "/why/the_hard_way/",
	"title": "The Hard Way",
	"tags": [],
	"description": "",
	"content": "If you\u0026rsquo;re reading this, you have probably been frustrated by code you wrote.\nMaybe a feature that you thought would take a few hours took a few days. Or a few weeks.\nMaybe a bug you fixed a month ago came back and you can\u0026rsquo;t stand the idea of trying to fix it again.\nMaybe you stare at your screen for hours wondering where a new structure could possibly fit into your program.\nMaybe you find yourself screaming WHY!!!! at your computer and throwing something across the room.\nI\u0026rsquo;m here to tell you that coding a game doesn\u0026rsquo;t have to be this hard.\nJust say it with me. It doesn\u0026rsquo;t have to be this hard. It doesn\u0026rsquo;t!\nThe road to recovery starts with some basic structural ideas and a little bit of discipline.\nCome along with me, won\u0026rsquo;t you? Let\u0026rsquo;s write some good code.\n"
},
{
	"uri": "/getting_started/case_study_love/",
	"title": "Case Study: LÖVE",
	"tags": [],
	"description": "",
	"content": "LÖVE is a 2D game engine that uses Lua as its scripting language. Because of this, we can use Encompass-TS with the TypescriptToLua transpiler to make games for it.\nIf you are new to TypeScript, or even new to programming in general, I strongly recommend reviewing the TypeScript handbook.\nInstall LÖVE.\nMake sure you can run it from the terminal by running:\nlove  You should see the LÖVE window pop up with the NO GAME screen. If you don\u0026rsquo;t see this, check your terminal environment. On Windows you probably need to manually add the path where you installed LÖVE to your Path Environment Variable and then restart the machine. Thanks Windows!\nEncompass-TS uses Node.js for its build process and npm to manage dependencies. Install Node, which automatically installs npm.\nMake sure it is properly installed by running:\nnpm  You should see npm print out a bunch of help information. Now we\u0026rsquo;re almost ready to begin.\nDownload the Encompass/LÖVE starter project. Place its contents in a folder and rename the folder to the name of your project. Change information in the package.json file where appropriate.\nNow we are ready. Enter the project folder in your terminal and do:\nnpm install  This will install everything you need to compile your project to Lua.\nThe starter project contains some scripts to automate the build process.\nTo create a clean build from scratch, do:\nnpm run build  To incrementally build your game as you make changes, do:\nnpm run watch  This will run continuously and build only files that change. It will reduce your build times significantly, so I recommend using it!\nTo copy your assets into the game build, do:\nnpm run copyassets  Make sure to do this if you are in incremental mode and make changes to assets.\nTo run your game, do:\nnpm run love  Or, on Windows:\nnpm run lovec  so that you get proper debug console output.\nIf you want to completely clean your build folder without making a new build, do:\nnpm run clean  That\u0026rsquo;s everything you need to start making a game with Encompass and LÖVE!\n"
},
{
	"uri": "/pong/draw_paddle/initialize_world/",
	"title": "Initializing the World",
	"tags": [],
	"description": "",
	"content": "It\u0026rsquo;s time to put it all together.\nLet\u0026rsquo;s look at our game/game.ts file. The load method looks like this:\npublic load() { this.canvas = love.graphics.newCanvas(); const world_builder = new WorldBuilder(); // ADD YOUR ENGINES HERE... // ADD YOUR RENDERERS HERE... // ADD YOUR STARTING ENTITIES HERE... this.world = world_builder.build(); }  Let\u0026rsquo;s do as the helpful file asks, eh?\nimport { CanvasRenderer } from \u0026quot;./renderers/canvas\u0026quot;; ... export class Game { ... public load() { this.canvas = love.graphics.newCanvas(); const world_builder = new WorldBuilder(); // ADD YOUR ENGINES HERE... // ADD YOUR RENDERERS HERE... world_builder.add_renderer(CanvasRenderer); // ADD YOUR STARTING ENTITIES HERE... this.world = world_builder.build(); } ...  Now our CanvasRenderer will exist in the world. We only have two things left to do: create a Canvas that contains our paddle visuals, and put it on an Entity.\nLet\u0026rsquo;s tell the World Builder that we want a new Entity. This will be our paddle Entity.\nconst paddle_entity = world_builder.create_entity();  Let\u0026rsquo;s set up our paddle Canvas.\nconst width = 4; const height = 8; const paddle_canvas = love.graphics.newCanvas(4, 8); love.graphics.setCanvas(paddle_canvas); love.graphics.setBlendMode(\u0026quot;alpha\u0026quot;); love.graphics.setColor(1, 1, 1, 1); love.graphics.rectangle(\u0026quot;fill\u0026quot;, 0, 0, length, 2); love.graphics.setCanvas();  All we\u0026rsquo;re doing here is setting up a Canvas and filling it with a white rectangle. If you want to break this down more, go ahead and read the love.graphics documentation.\nNow we need to attach the canvas to the CanvasComponent.\nconst canvas_component = paddle_entity.add_component(CanvasComponent); canvas_component.canvas = paddle_canvas; canvas_component.x_scale = 1; canvas_component.y_scale = 1;  Finally, let\u0026rsquo;s set up its position.\nconst position_component = paddle_entity.add_component(PositionComponent); position_component.x = 40; position_component.y = 40;  Our final game/game.ts should look like this:\nimport { World, WorldBuilder } from \u0026quot;encompass-ecs\u0026quot;; import { CanvasComponent } from \u0026quot;./components/canvas\u0026quot;; import { PositionComponent } from \u0026quot;./components/position\u0026quot;; import { CanvasRenderer } from \u0026quot;./renderers/canvas\u0026quot;; export class Game { private world: World; private canvas: Canvas; public load() { this.canvas = love.graphics.newCanvas(); const world_builder = new WorldBuilder(); // ADD YOUR ENGINES HERE... // ADD YOUR RENDERERS HERE... world_builder.add_renderer(CanvasRenderer); // ADD YOUR STARTING ENTITIES HERE... const paddle_entity = world_builder.create_entity(); const width = 4; const height = 8; const paddle_canvas = love.graphics.newCanvas(width, height); love.graphics.setCanvas(paddle_canvas); love.graphics.setBlendMode(\u0026quot;alpha\u0026quot;); love.graphics.setColor(1, 1, 1, 1); love.graphics.rectangle(\u0026quot;fill\u0026quot;, 0, 0, width, height); love.graphics.setCanvas(); const canvas_component = paddle_entity.add_component(CanvasComponent); canvas_component.canvas = paddle_canvas; canvas_component.x_scale = 1; canvas_component.y_scale = 1; const position_component = paddle_entity.add_component(PositionComponent); position_component.x = 40; position_component.y = 40; this.world = world_builder.build(); } public update(dt: number) { this.world.update(dt); } public draw() { love.graphics.clear(); love.graphics.setCanvas(this.canvas); love.graphics.clear(); this.world.draw(); love.graphics.setCanvas(); love.graphics.setBlendMode(\u0026quot;alpha\u0026quot;, \u0026quot;premultiplied\u0026quot;); love.graphics.setColor(1, 1, 1, 1); love.graphics.draw(this.canvas); } }  Let\u0026rsquo;s run the game!!\n"
},
{
	"uri": "/concepts/engine/",
	"title": "Engine",
	"tags": [],
	"description": "",
	"content": "An Engine is the Encompass notion of an ECS System. Much like the engine on a train, your Engines make the simulation move along.\nI never liked the term System. It is typically used to mean structures in game design and I found this confusing when discussing code implementation vs design.\n Engines are responsible for reading the game state, reading messages, emitting messages, and creating or mutating Entities and Components.\nAn Engine which Reads a particular message is guaranteed to run after all Engines which Emit that particular message.\nTo define an Engine, extend the Engine class.\nHere is an example Engine:\nimport { Engine, Mutates, Reads } from \u0026quot;encompass-ecs\u0026quot;; import { LogoUIComponent } from \u0026quot;../../components/ui/logo\u0026quot;; import { ShowUIMessage } from \u0026quot;../../messages/show_ui\u0026quot;; @Reads(ShowUIMessage) @Mutates(LogoUIComponent) export class LogoDisplayEngine extends Engine { public update() { const logo_ui_component = this.read_component_mutable(LogoUIComponent); if (logo_ui_component \u0026amp;\u0026amp; this.some(ShowUIMessage)) { logo_ui_component.image.isVisible = true; } } }  If a LogoUIComponent exists, and a ShowUIMessage is received, it will make the logo image on the LogoUIComponent visible. Simple!\n"
},
{
	"uri": "/concepts/",
	"title": "Concepts",
	"tags": [],
	"description": "",
	"content": " Chapter 3 Concepts It\u0026rsquo;s time for some non-specifics.\n"
},
{
	"uri": "/getting_started/project_structure/",
	"title": "LÖVE Project Structure",
	"tags": [],
	"description": "",
	"content": "Structuring your project is a crucial component of keeping your Encompass development sane. Let\u0026rsquo;s review how an Encompass project is typically structured.\nIf we look at the Encompass/LÖVE starter project, it looks like this:\nmain.ts is the entry point of the game for LÖVE. You can change top-level configuration things here, like setting the window size or whether the mouse is visible. You should review the LÖVE Documentation for more clarification.\nconf.ts defines certain information about the game. You can read more about LÖVE Config Files here.\ngame/game.ts contains a class that defines three methods that are called by LOVE: load, update, and draw. They do what it says on the tin. You will set up your WorldBuilder in the load method. (We\u0026rsquo;ll talk about that in a bit.)\nThe rest of it is pretty straightforward. Put your music and sprites and such in the assets folder. Define your components in the components folder, your engines in the engines folder, your messages in the messages folder, and your renderers in the renderers folder. (Again, we\u0026rsquo;ll start getting into exactly how to define these in a minute.)\nFinally, a quick note about helpers. I like to use classes with static methods for common behaviors that will be useful for many different engines, for example a Color class with a hsv_to_rgb conversion function. Be careful not to abuse helpers. If your helpers need to be instantiated, that is usually a sign that the behavior belongs in an engine.\n"
},
{
	"uri": "/why/architecture/mess/",
	"title": "The Messy Basement",
	"tags": [],
	"description": "",
	"content": "Unexpected behavior jumps out at you constantly. You feel like you\u0026rsquo;re playing whack-a-mole with bugs. You can\u0026rsquo;t remember where you put anything and keeping everything sorted is a constant nightmare.\nUh oh. You\u0026rsquo;re in a messy basement.\nSome characteristics of the messy basement:\n Magic values, aka putting numbers directly in the source code. Game objects directly manipulating each other\u0026rsquo;s values willy-nilly. Multiple objects that keep track of and depend on each other\u0026rsquo;s state.  The key characteristic of this structure is that there almost doesn\u0026rsquo;t seem to be any structure at all.\nShockingly, some game engines and frameworks not only fail to prevent this kind of architecture, they actually encourage it!\n\u0026ldquo;But I know where everything is!\u0026rdquo; Tell that to yourself three months from now.\nI don\u0026rsquo;t need to say much more about this kind of architecture. It\u0026rsquo;s obviously bad. Let\u0026rsquo;s move on.\n"
},
{
	"uri": "/notes/license/",
	"title": "License",
	"tags": [],
	"description": "",
	"content": "This project is licensed under the Cooperative Software License. You should have received a copy of this license with the framework code. If not, the full text of the License is provided here.\nThe long and short of it is that if you are working for commercial purposes on behalf of a corporation and not for yourself as a hobbyist individual or a worker-owned cooperative, you are not welcome to use this software as-is. You are also not welcome to redistribute the program under your own terms.\nIf you would like to use this software for commercial purposes, please contact Evan Hemsley to negotiate an appropriate licensing agreement.\n"
},
{
	"uri": "/pong/polish/title/",
	"title": "Title",
	"tags": [],
	"description": "",
	"content": "It would be nice to have a title screen. Let\u0026rsquo;s make that happen.\nI would like us to have a concept of game state. The title menu is a pretty distinct thing from the game itself so it feels nicer to have it be self contained instead of managing extra state in the game world.\nLet\u0026rsquo;s create a new class in game/state.ts:\nexport abstract class State { public abstract load(): void; public abstract update(dt: number): void; public abstract draw(): void; }  Remember, abstract means that the class cannot be used directly, but describes features that exist in inherited classes. So we know that anything we make that inherits from State must have a load(), update(dt), and draw() method.\nLet\u0026rsquo;s create a new folder, game/states, and put game.ts in there. Let\u0026rsquo;s also make it inherit from State:\nexport class Game extends State {  Let\u0026rsquo;s make a new State called Title. It doesn\u0026rsquo;t need to do much - just display the game title and a prompt for the player to start the game.\nimport { State } from \u0026quot;game/state\u0026quot;; export class Title extends State { private title_font: Font; private title_text: Text; private play_font: Font; private play_text: Text; public load() { this.title_font = love.graphics.newFont(\u0026quot;game/assets/fonts/Squared Display.ttf\u0026quot;, 128); this.title_text = love.graphics.newText(this.title_font, \u0026quot;Encompass Pong\u0026quot;); this.play_font = love.graphics.newFont(\u0026quot;game/assets/fonts/Squared Display.ttf\u0026quot;, 32); this.play_text = love.graphics.newText(this.play_font, \u0026quot;Press Space\u0026quot;); } public update() {} public draw() { love.graphics.draw( this.title_text, 640, 240, 0, 1, 1, this.title_text.getWidth() * 0.5, this.title_text.getHeight() * 0.5, ); love.graphics.draw( this.play_text, 640, 480, 0, 1, 1, this.play_text.getWidth() * 0.5, this.play_text.getHeight() * 0.5, ); } }  Now in main.ts we can put code to handle our states.\nlet menu: Title; let game: Game; let current_state: State; love.load = () =\u0026gt; { ... menu = new Menu(); menu.load(); game = new Game(); game.load(); current_state = menu; }; love.update = (dt) =\u0026gt; { current_state.update(dt); if (current_state === menu) { if (love.keyboard.isDown(\u0026quot;space\u0026quot;)) { current_state = game; } } }; love.draw = () =\u0026gt; { current_state.draw(); ... }  The final result of main.ts should look like this.\ndeclare global {let PROF_CAPTURE: boolean; } PROF_CAPTURE = false; // set this to true to enable profiling import * as jprof from \u0026quot;encompass-jprof\u0026quot;; import { State } from \u0026quot;game/state\u0026quot;; import { Game } from \u0026quot;game/states/game\u0026quot;; import { Title } from \u0026quot;game/states/title\u0026quot;; let menu: Title; let game: Game; let current_state: State; love.load = () =\u0026gt; { love.window.setMode(1280, 720, {vsync: false, msaa: 2}); love.math.setRandomSeed(os.time()); love.mouse.setVisible(false); menu = new Title(); menu.load(); game = new Game(); game.load(); current_state = menu; }; love.update = (dt) =\u0026gt; { current_state.update(dt); if (current_state === menu) { if (love.keyboard.isDown(\u0026quot;space\u0026quot;)) { current_state = game; } } }; love.draw = () =\u0026gt; { current_state.draw(); love.graphics.setBlendMode(\u0026quot;alpha\u0026quot;); love.graphics.setColor(1, 1, 1, 1); love.graphics.print(\u0026quot;Current FPS: \u0026quot; + tostring(love.timer.getFPS()), 10, 10); }; love.quit = () =\u0026gt; { jprof.write(\u0026quot;prof.mpack\u0026quot;); return false; };  Let\u0026rsquo;s try it!\nNice!\n"
},
{
	"uri": "/pong/scoring/ball_respawn/",
	"title": "Ball Respawn",
	"tags": [],
	"description": "",
	"content": "In Pong, when the ball collides with the goal, we want it to respawn after a set amount of time, fired from a random point in the center of the play area in a variable direction.\nWe can easily implement a timer by using a Component.\nLet\u0026rsquo;s create a new Entity: a timed ball spawner.\nYou should be getting fairly familiar with this process by now. We\u0026rsquo;ll need a Component, a Message, and a Spawner.\nIn game/components/ball_spawn_timer.ts:\nimport { Component } from \u0026quot;encompass-ecs\u0026quot;; export class BallSpawnTimerComponent extends Component { public time_remaining: number; }  In game/messages/ball_spawn_timer_spawn.ts:\nimport { Message } from \u0026quot;encompass-ecs\u0026quot;; export class BallSpawnTimerSpawnMessage extends Message { public time: number; }  In game/engines/spawners/ball_spawn_timer.ts:\nimport { Reads, Spawner } from \u0026quot;encompass-ecs\u0026quot;; import { BallSpawnTimerComponent } from \u0026quot;game/components/ball_spawn_timer\u0026quot;; import { BallSpawnTimerSpawnMessage } from \u0026quot;game/messages/ball_spawn_timer_spawn\u0026quot;; @Reads(BallSpawnTimerSpawnMessage) export class BallSpawnTimerSpawner extends Spawner { public spawn_message_type = BallSpawnTimerSpawnMessage; public spawn(message: BallSpawnTimerSpawnMessage) { const entity = this.create_entity(); const component = entity.add_component(BallSpawnTimerComponent); component.time_remaining = message.time; } }  Finally we need an Engine to control the timer behavior and the firing of the ball spawn message.\nWhen we serve the ball in Pong, it fires from a random position along the center line at a random angle (with some constraints). Sound\u0026rsquo;s like we\u0026rsquo;re gonna need some vector math.\nIf you don\u0026rsquo;t know anything about vectors, a 2D vector is simply a mathematical structure composed of an x and y component. We generally use them to represent both position and velocity. There are certain clever mathematical operations we can do on vectors that make them very useful for games.\nIt turns out there is a very useful Lua library for 2D vector math in a repository called HUMP. Download it here.\nCreate a new directory, lua-lib/hump, and add vectorlight.lua to the directory. Let\u0026rsquo;s write a declaration file to go along with it.\nIn lua-lib/hump/vectorlight.d.ts:\n/** @noSelfInFile */ export function str(x: number, y: number): string; /** @tupleReturn */ export function mul(s: number, x: number, y: number): [number, number]; /** @tupleReturn */ export function div(s: number, x: number, y: number): [number, number]; /** @tupleReturn */ export function add(x1: number, y1: number, x2: number, y2: number): [number, number]; /** @tupleReturn */ export function sub(x1: number, y1: number, x2: number, y2: number): [number, number]; /** @tupleReturn */ export function permul(x1: number, y1: number, x2: number, y2: number): [number, number]; export function dot(x1: number, y1: number, x2: number, y2: number): number; export function det(x1: number, y1: number, x2: number, y2: number): number; export function eq(x1: number, y1: number, x2: number, y2: number): boolean; export function lt(x1: number, y1: number, x2: number, y2: number): boolean; export function le(x1: number, y1: number, x2: number, y2: number): boolean; export function len2(x: number, y: number): number; export function len(x: number, y: number): number; /** @tupleReturn */ export function fromPolar(angle: number, radius: number): [number, number]; /** @tupleReturn */ export function randomDirection(len_min: number, len_max: number): [number, number]; /** @tupleReturn */ export function toPolar(x: number, y: number): [number, number]; export function dist2(x1: number, y1: number, x2: number, y2: number): number; export function dist(x1: number, y1: number, x2: number, y2: number): number; /** @tupleReturn */ export function normalize(x: number, y: number): [number, number]; /** @tupleReturn */ export function rotate(phi: number, x: number, y: number): [number, number]; /** @tupleReturn */ export function perpendicular(x: number, y: number): [number, number]; /** @tupleReturn */ export function project(x: number, y: number, u: number, v: number): [number, number]; /** @tupleReturn */ export function mirror(x: number, y: number, u: number, v: number): [number, number]; /** @tupleReturn */ export function trim(maxLen: number, x: number, y: number): [number, number]; export function angleTo(x: number, y: number, u: number, v: number): number;  Now we can use all these useful vector math functions in our game.\nLet\u0026rsquo;s break down some of the math here.\nWe want the ball to fire in a random direction, but we don\u0026rsquo;t want its trajectory to be too vertical, or it will take forever to get to one of the paddles, which is boring. We also want it to travel at the same speed regardless of its direction.\nLet\u0026rsquo;s start with a vector with an x component of our desired speed and a y component of 0. You can think of this as an arrow pointing directly to the right. Now imagine that arrow as the hand of a clock. How can we describe the angle of the clock hand? As the hand rotates around it differs from its original orientation in an amount of units called radians. When that angle changes by 2 times pi, it ends up in the same position. So a rotation a quarter of the way around the clock would be pi divided by 2.\nYou can see that if we rotate our direction vector by pi/2 radians, it will face straight down. Now, what we want is for the ball to be served at angles like this:\nThe non-shaded area represents the angles that we want the ball to be served at. What angle is that exactly?\nWell, a lot of what we do in game math is guesstimation. \u0026ldquo;Close enough\u0026rdquo; can be a powerful phrase! We can always easily tweak the exact values later if we architect our game properly.\nIf we draw it out, we know that a quarter-circle rotation is pi/2 radians. The angle of our serve range seems to be roughly half that. So our rotation would be pi/4 radians. Sounds reasonable as a starting angle to me. How do we actually represent this range?\nWhat if the rotation is negative? Well, our positive rotations have been going clockwise - so negative rotations go counter-clockwise! That means our possible serve angle is somewhere between -pi/4 and pi/4.\nSo now we need to actually pick a random rotation within this range. How should we do that? TypeScript and Lua don\u0026rsquo;t have anything built-in for this. I usually write a helper for this, since it\u0026rsquo;s so common to want a random real number in a certain range.\nLet\u0026rsquo;s create game/helpers/math.ts:\nexport class MathHelper { public static randomFloat(low: number, high: number): number { return love.math.random() * high + low; } }  love.math.random() returns a random real number between 0 and 1. So our randomFloat function will return a random real number between low and high.\nNow we can construct a formula for our random serve direction.\nconst direction = MathHelper.randomFloat(-math.pi / 4, math.pi / 4);  Now we need the ball to be able to be served left or right. To make our direction point left, we can make the x component of the vector negative.\nconst horizontal_speed = this.ball_speed * (love.math.random() \u0026gt; 0.5 ? 1 : -1);  Remember, love.math.random() returns a random number between 0 and 1. It has a 50% chance of being greater than 0.5. So this expression means there\u0026rsquo;s a 50% chance of that value being equal to 1, and a 50% chance of it being equal to -1. If we multiply the direction by negative 1, we are reversing its direction, so we have an equal chance of the ball being served to the left or the right. Spiffy!\nNow we can put it all together to get our final velocity.\n[ ball_spawn_message.x_velocity, ball_spawn_message.y_velocity, ] = vectorlight.rotate(direction, horizontal_speed, 0);  This is an example of a destructuring assignment. It lets us multiple variables at the same time, which is particularly useful for vector math. You can read more about it on the official TypeScript documentation.\nWhy aren\u0026rsquo;t we just using an object to represent the vector?\nGood question! My personal reason is that in Lua objects need to be garbage collected once they are done being used, so I like to avoid creating them when possible to avoid frame spikes, which is when a frame takes significantly longer to render than other frames. Regular numbers are not garbage collected so there is no danger of this happening.\n Let\u0026rsquo;s put it all together.\nIn game/engines/ball_spawn_timer.ts:\nimport { Emits, Engine, Mutates } from \u0026quot;encompass-ecs\u0026quot;; import { BallSpawnTimerComponent } from \u0026quot;game/components/ball_spawn_timer\u0026quot;; import { MathHelper } from \u0026quot;game/helpers/math\u0026quot;; import { BallSpawnMessage } from \u0026quot;game/messages/ball_spawn\u0026quot;; import * as vectorlight from \u0026quot;lua-lib/hump/vectorlight\u0026quot;; @Mutates(BallSpawnTimerComponent) @Emits(BallSpawnMessage) export class BallSpawnTimerEngine extends Engine { private ball_size: number; private ball_speed: number; private serve_angle: number; private middle: number; private height: number; public initialize( ball_size: number, ball_speed: number, serve_angle: number, middle: number, height: number, ) { this.ball_size = ball_size; this.ball_speed = ball_speed; this.serve_angle = serve_angle; this.middle = middle; this.height = height; } public update(dt: number) { for (const component of this.read_components_mutable(BallSpawnTimerComponent).values()) { component.time_remaining -= dt; if (component.time_remaining \u0026lt;= 0) { const ball_spawn_message = this.emit_message(BallSpawnMessage); ball_spawn_message.x = this.middle; ball_spawn_message.y = love.math.random() * this.height; const direction = MathHelper.randomFloat( -this.serve_angle, this.serve_angle, ); const horizontal_speed = this.ball_speed * (love.math.random() \u0026gt; 0.5 ? 1 : -1); [ ball_spawn_message.x_velocity, ball_spawn_message.y_velocity, ] = vectorlight.rotate(direction, horizontal_speed, 0); ball_spawn_message.size = this.ball_size; this.get_entity(component.entity_id)!.destroy(); } } } }  Every frame we subtract the remaining time by the delta-time value. Once it less than or equal to zero, we fire a BallSpawnMessage and destroy the timer entity.\nNotice that we remembered to destroy our timer entity at the end so it doesn\u0026rsquo;t keep firing new ball spawn messages every frame. That would be bad!\nDon\u0026rsquo;t forget to register our new Engines with the WorldBuilder.\nworld_builder.add_engine(BallSpawnTimerSpawner); world_builder.add_engine(BallSpawnTimerEngine).initialize( ball_size, ball_speed, math.pi / 4, 3 * math.pi / 4, play_area_width * 0.5, play_area_height, );  While we\u0026rsquo;re in game.ts, let\u0026rsquo;s also change our game start ball spawn to use our fancy new timer based ball spawn system.\nconst ball_timer_spawn_message = world_builder.emit_message(BallSpawnTimerSpawnMessage); ball_timer_spawn_message.time = 1;  The moment of truth\u0026hellip;\n Not bad. The angle is probably a bit generous as it is but we can leave it for now.\n"
},
{
	"uri": "/pong/ball/moving/",
	"title": "Moving",
	"tags": [],
	"description": "",
	"content": "We already have MotionMessages and a MotionEngine. So it seems logical to re-use these structures for our ball.\nWhat is actually going to be sending out the MotionMessages?\nWhat is the main characteristic of the ball in Pong? That\u0026rsquo;s right - it is continuously moving. In other words, it has velocity.\nLet\u0026rsquo;s make a VelocityComponent. In game/components/velocity.ts:\nimport { Component } from \u0026quot;encompass-ecs\u0026quot;; export class VelocityComponent extends Component { public x: number; public y: number; }  Let\u0026rsquo;s also create a VelocityEngine.\nWhat does our VelocityEngine actually do? Basically, if something has both a PositionComponent and VelocityComponent, we want the PositionComponent to update based on the VelocityComponent every frame.\nIt turns out Encompass provides a structure for this pattern, called a Detector. Let\u0026rsquo;s use it now.\nIn game/engines/velocity.ts:\nimport { Detector, Emits, Entity } from \u0026quot;encompass-ecs\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; import { VelocityComponent } from \u0026quot;game/components/velocity\u0026quot;; import { MotionMessage } from \u0026quot;game/messages/component/motion\u0026quot;; @Emits(MotionMessage) @Detects(PositionComponent, VelocityComponent) export class VelocityEngine extends Detector { protected detect(entity: Entity) { const position_component = entity.get_component(PositionComponent); const velocity_component = entity.get_component(VelocityComponent); const motion_message = this.emit_component_message(MotionMessage, position_component); motion_message.x = velocity_component.x; motion_message.y = velocity_component.y; } }  A Detector, like a Spawner, is an engine with one required method: detect.\nWhen an Entity has all of the components specified in @Detects, it begins to track the Entity. Each frame, it calls its detect method on that Entity.\nSo, our VelocityEngine will track everything with a PositionComponent and VelocityComponent and create a MotionMessage every frame.\nLet\u0026rsquo;s add our new Engine to the WorldBuilder:\nworld_builder.add_engine(VelocityEngine);  And add our new VelocityComponent in the BallSpawner.\nconst velocity_component = ball_entity.add_component(VelocityComponent); velocity_component.x = 50; velocity_component.y = -50;  Actually lets get rid of that magic value by adding velocity to the BallSpawnMessage.\ngame/messages/ball_spawn.ts\nimport { Message } from \u0026quot;encompass-ecs\u0026quot;; export class BallSpawnMessage extends Message { public x: number; public y: number; public size: number; public x_velocity: number; public y_velocity: number; }  game/engines/spawners/ball.ts\nconst velocity_component = ball_entity.add_component(VelocityComponent); velocity_component.x = message.x_velocity; velocity_component.y = message.y_velocity;  game/game.ts\nball_spawn_message.x_velocity = 50; ball_spawn_message.y_velocity = -50;  Let\u0026rsquo;s run the game again.\n Still pretty boring but we\u0026rsquo;re getting somewhere.\n"
},
{
	"uri": "/pong/move_paddle/frame_dependence/",
	"title": "Frame-Dependence",
	"tags": [],
	"description": "",
	"content": "Oh dear. That doesn\u0026rsquo;t seem right at all.\nThe paddle is moving way too fast. But our speed value is only 10. What\u0026rsquo;s going on?\nRemember when I mentioned frame-dependence and delta-time earlier? This is a classic example of frame-dependence. Notice that the FPS, or frames-per-second, of the game is around 500 in the above recording. Our motion message when we press the \u0026ldquo;up\u0026rdquo; key on the keyboard tells the paddle to move 10 units.\nThat means every frame we have the \u0026ldquo;up\u0026rdquo; key held down, the paddle is moving 10 units. Which means, as things stand right now, the paddle is moving about 5000 units per second. And if the framerate changes for some reason, the paddle will move slower or quicker. This means the actual progress of the simulation will be completely different on slower or faster computers.\nThis is where delta-time comes in to save the day.\ndelta-time, as I mentioned before, is the amount of time that has passed between the previous frame and the current frame.\nIf we multiply the rate of change of the position by delta-time, then the paddle will move at the same speed no matter whether the framerate changes.\nLet\u0026rsquo;s go back to the lines of the MotionEngine where we update the position.\nposition_component.x += message.x * dt; position_component.y += message.y * dt;  Our simulation is now frame-independent, which is what we desire. The paddle is definitely moving too slowly now, but that\u0026rsquo;s something we can fix with a bit of value tweaking.\nIt is very important that you take care to multiply things that change over time by the delta-time value, or you risk elements of your game becoming frame-dependent.\n"
},
{
	"uri": "/pong/draw_paddle/first_run/",
	"title": "First Run",
	"tags": [],
	"description": "",
	"content": "All we have to do now is run our build and run script in the terminal.\n\u0026gt; npm run love  Exciting!! Let\u0026rsquo;s see what happens\u0026hellip;\nOh dear. That paddle is quite small. Bit of a buzzkill really.\nconst width = 20; const height = 120;  position_component.x = 40; position_component.y = 360;  Thaaaaaaat\u0026rsquo;s more like it.\nNotice how we can just change simple Component values, and the result of the simulation changes. In a larger project we would probably want to define these Component values in a separate file that lives on its own. This is called data-driven design and it is a powerful feature of ECS-like architectures. When we do data-driven design, we can modify the game without even looking at source code - just change some values in a file and the game changes! If we wanted to get really clever, we could probably have an in-game editor that changes these values even while the game is running!\nBut for such a simple example, leaving this in the load function is probably fine. Let\u0026rsquo;s move on and get this paddle moving.\n"
},
{
	"uri": "/pong/",
	"title": "Pong",
	"tags": [],
	"description": "",
	"content": " Chapter 4 Pong The game of games.\n"
},
{
	"uri": "/why/architecture/oop/",
	"title": "OOP",
	"tags": [],
	"description": "",
	"content": " They call it OOP because it was a mistake. \u0026ndash;Unknown You are probably very familiar with OOP, or object-oriented programming, as a game designer. It is the structural idea behind most games as they are written today, though this is slowly changing.\nOOP is a structure based on the concept of Objects. Objects contain both data, referred to as properties, and logic, referred to as methods.\nObject orientation is an intuitive idea when it comes to building simulation-oriented applications such as video games. We think of each \u0026ldquo;thing\u0026rdquo; in the game as a self-contained object which can be acted upon externally via methods. For example, in the game Asteroids, we could think of the game this way: the ship is an object, the bullets the ship fires are objects, the asteroids are objects, and so on.\nUnfortunately, things aren\u0026rsquo;t quite this simple when it comes to more complex games.\nAs programmers we want to re-use code as much as possible. Every bit of duplication is an opportunity for bugs to lurk in our program. Object-oriented code accomplishes re-use with a concept called inheritance. With inheritance, classes can be partially based on other classes. Maybe a Ball class has a position and a velocity and a bounciness property. A BouncyBall would inherit from Ball and have a greater value in its bounciness property. Simple enough, right?\nBut we soon run into problems. In game development we often wish to mix-and-match behaviors. Suppose I have an object where it would make sense to inherit from two different classes. Now\u0026hellip; we are hosed! Why? If two parent classes have a property or a method with the same name, now our child object has no idea what to do. Most object-oriented systems, in fact, forbid multiple inheritance, and the ones that don\u0026rsquo;t forbid it require very complex definitions to make it work. So we end up having to share code via helper functions, or giant manager classes, or other awkward patterns.\nWe also run into an issue called tight coupling. Objects that reference each other\u0026rsquo;s properties or methods directly become a problem when we change the structure of those objects in any way. If we modify the structure of object B, and object A references object B, then we have to also modify object A. In a particularly poorly structured system, we might have to modify a dozen objects just to make a slight modification to the behavior of a single object.\nTight coupling is our worst nightmare as game programmers. Games are, by nature, extremely complex simulations. The more coupling we have between objects, the more of the entire environment of the game we have to understand before we can pick apart the specific behavior of a single object, let alone the whole game itself. It is very possible that we can surprise ourselves by unexpectedly changing the behavior of different objects when modifying a single object. And we hate surprises.\nWe want our architecture to encourage us to create as little coupling as possible between different elements of the game, so that we can look at any individual element of the game and easily understand how it behaves without needing to deeply understand the other elements of the game. We also wish to modify behavior without introducing unexpected changes in other seemingly unrelated objects. OOP works in very specific encapsulated cases, but it is not a satisfactory structure for implementing game behavior.\nIt turns out there is an architecture that addresses our desire to be able to compose objects out of several different behaviors. Let\u0026rsquo;s learn about it.\n"
},
{
	"uri": "/why/architecture/",
	"title": "Architecture",
	"tags": [],
	"description": "",
	"content": "Architecture simply means the basic structure of a program, and how things are added to the program. It is the foundation of everything you build.\nAll programs that you write have some kind of architecture, even if you haven\u0026rsquo;t really thought about it much. Let\u0026rsquo;s go over some different architectures and talk about their features.\n"
},
{
	"uri": "/pong/move_paddle/magic_values/",
	"title": "Magic Values",
	"tags": [],
	"description": "",
	"content": "Our code right now is violating one more good architecture principle.\nif (love.keyboard.isDown(\u0026quot;up\u0026quot;)) { const message = this.emit_component_message(MotionMessage, player_one_position_component); message.x = 0; message.y = -10; }  Magic values refer to numbers that have been placed directly in the code. The values being set to message.x and message.y above are magic values. Why are magic values bad?\nMagic values introduce the possibility of duplication. Let\u0026rsquo;s say I start adding my code to be able to move paddles down. Now I have to change the numbers in two different places. If I ever change one without changing the other, I have introduced a bug.\nThere\u0026rsquo;s another reason to avoid magic values too. Suppose I haven\u0026rsquo;t looked at the InputEngine for a while, but I suddenly decide that the paddles are moving too slow. Intuitively, I would want to look for a Component that contains those values, but instead, they would be hidden in the InputEngine. This isn\u0026rsquo;t what you would really expect - why would Input have anything to do with the speed of the paddles?\nOrganizing your information consistently is crucial to being able to easily find things that you need to change. You\u0026rsquo;ll thank yourself later.\nLet\u0026rsquo;s make a new Component.\nCreate a file: game/components/paddle_move_speed.ts\nimport { Component } from \u0026quot;encompass-ecs\u0026quot;; export class PaddleMoveSpeedComponent extends Component { public y: number; }  And let\u0026rsquo;s add it to our paddle Entity.\nIn game/game.ts\nconst move_speed_component = paddle_entity.add_component(PaddleMoveSpeedComponent); move_speed_component.y = 10;  Now let\u0026rsquo;s tell our InputEngine to use it, and why don\u0026rsquo;t we go ahead and make the \u0026ldquo;down\u0026rdquo; key move the paddle downward too.\n... if (player_one_entity) { const player_one_position_component = player_one_entity.get_component(PositionComponent); const player_one_move_speed_component = player_one_entity.get_component(PaddleMoveSpeedComponent); if (love.keyboard.isDown(\u0026quot;up\u0026quot;)) { const message = this.emit_component_message(MotionMessage, player_one_position_component); message.x = 0; message.y = -player_one_move_speed_component.y; } else if (love.keyboard.isDown(\u0026quot;down\u0026quot;)) { const message = this.emit_component_message(MotionMessage, player_one_position_component); message.x = 0; message.y = player_one_move_speed_component.y; } } ...  I\u0026rsquo;m starting to get get a bad feeling about this. Are you? Let me explain.\n"
},
{
	"uri": "/why/architecture/ecs/",
	"title": "ECS",
	"tags": [],
	"description": "",
	"content": "ECS stands for Entity-Component-System. It is based on two fundamental principles:\n There should be complete separation between data and logic. Objects should be created via composition and not inheritance.  Components are the most basic element. They are simply containers of related data. In a 2D game we could have a PositionComponent with an x and y value. Components do not contain logic, though they might have callbacks to deal with side effects, for example creating or destroying bodies in a physics simulator.\nEntities are generic objects, which have a unique ID and a collection of Components. Entities have no inherent behavior or properties of their own, but are granted these by Components. We can add, remove, or modify Components of Entities as necessary during the simulation.\nSystems are responsible for reading and modifying Entities and Components. For example, a MotionSystem might look at Entities that have both a PositionComponent and VelocityComponent, and update the PositionComponent based on the information in the VelocityComponent.\nNotice, in our above example, that this gives us a tremendous amount of flexibility. We can completely remove the VelocityComponent from an Entity while the game is running, and the Entity will simply stop moving - nothing else will break, because nothing has to rely on an Entity specifically containing a VelocityComponent! This is the power of composition and de-coupling at work.\nUnfortunately, ECS is not without its problems.\nSuppose we have a game where the player character can move left or right, and also has a special ability that lets them teleport forward over a short distance. We could put all of this logic in the same System, but most Entities that move around are not going to have this behavior, so it makes sense to have a separate system. In other words, we have introduced multiple systems that need to manipulate the position of objects.\nWe could have a TeleportSystem that immediately sets the x and y value of the PositionComponent so it is in front of the player\u0026rsquo;s current position. But if the TeleportSystem runs before our regular Motion System, the Position Component will be overwritten by the regular Motion System and we will not see the teleportation behavior occur, even though the system is running!\nThis kind of bug is known as a race condition. Race conditions are one of the worst kinds of bug to handle, because it is incredibly hard to trace values being over-written by other values. In my experience, race conditions are probably a good 80% of what game programmers deal with. No wonder we are so frustrated all the time!\nIn my opinion, being forced to think about the order in which Systems run is a form of tight coupling, because it means you have to consider the behavior of other systems when writing a new system to avoid introducing bugs.\nThis example also illustrates another problem with ECS: in Systems that have similar behavior, we don\u0026rsquo;t really have a nice structure to share that behavior.\nI have created a variant of ECS that intends to address these and other problems. Let me tell you about it.\n"
},
{
	"uri": "/pong/polish/win_condition/",
	"title": "Win Condition",
	"tags": [],
	"description": "",
	"content": "There\u0026rsquo;s one critical element missing from our game. Right now, once the game starts, it keeps going until the player exits the program. We need a win condition, and to indicate when that win condition has been reached.\nFirst let\u0026rsquo;s create two separate components - one that holds information about the victory, and one that counts down to when the game should return to the title screen.\nimport { Component } from \u0026quot;encompass-ecs\u0026quot;; export class WinDisplayComponent extends Component { public player_index: number; }  import { Component } from \u0026quot;encompass-ecs\u0026quot;; export class FinishGameTimerComponent extends Component { public time_remaining: number; }  Now we\u0026rsquo;ll create an engine that checks the game score and emits a message if one player has reached that score.\nimport { Emits, Engine } from \u0026quot;encompass-ecs\u0026quot;; import { GoalOneComponent } from \u0026quot;game/components/goal_one\u0026quot;; import { GoalTwoComponent } from \u0026quot;game/components/goal_two\u0026quot;; import { ScoreComponent } from \u0026quot;game/components/score\u0026quot;; import { WinDisplayComponent } from \u0026quot;game/components/win_display\u0026quot;; import { WinMessage } from \u0026quot;game/messages/win\u0026quot;; @Emits(WinMessage) export class CheckScoreEngine extends Engine { private winning_score: number; public initialize(winning_score: number) { this.winning_score = winning_score; } public update() { if (this.read_component(WinDisplayComponent)) { return; } const goal_one_component = this.read_component(GoalOneComponent); const goal_two_component = this.read_component(GoalTwoComponent); if (goal_one_component \u0026amp;\u0026amp; goal_two_component) { const goal_one_entity = this.get_entity(goal_one_component.entity_id); const goal_two_entity = this.get_entity(goal_two_component.entity_id); if (goal_one_entity \u0026amp;\u0026amp; goal_two_entity) { const score_one_component = goal_one_entity.get_component(ScoreComponent); const score_two_component = goal_two_entity.get_component(ScoreComponent); const score_one = score_one_component.score; const score_two = score_two_component.score; if (score_one \u0026gt;= this.winning_score) { const win_message = this.emit_message(WinMessage); win_message.player_index = 1; } else if (score_two \u0026gt;= this.winning_score) { const win_message = this.emit_message(WinMessage); win_message.player_index = 0; } } } } }  Now we can create an Engine that receives the WinMessage and adds new components to the game world.\nimport { Engine, Reads } from \u0026quot;encompass-ecs\u0026quot;; import { FinishGameTimerComponent } from \u0026quot;game/components/finish_game_timer\u0026quot;; import { WinDisplayComponent } from \u0026quot;game/components/win_display\u0026quot;; import { WinMessage } from \u0026quot;game/messages/win\u0026quot;; @Reads(WinMessage) export class WinEngine extends Engine { public update() { const win_messages = this.read_messages(WinMessage); for (const win_message of win_messages.values()) { const entity = this.create_entity(); const component = entity.add_component(WinDisplayComponent); component.player_index = win_message.player_index; const timer_entity = this.create_entity(); const timer_component = timer_entity.add_component(FinishGameTimerComponent); timer_component.time_remaining = 3; } } }  We want to see a win message display, so let\u0026rsquo;s create a new GeneralRenderer that shows one.\nimport { GeneralRenderer } from \u0026quot;encompass-ecs\u0026quot;; import { WinDisplayComponent } from \u0026quot;game/components/win_display\u0026quot;; export class WinRenderer extends GeneralRenderer { public layer = 2; private win_font: Font; private win_text: Text; private x: number; private y: number; private padding: number; public initialize(x: number, y: number, padding: number) { this.win_font = love.graphics.newFont(\u0026quot;game/assets/fonts/Squared Display.ttf\u0026quot;, 128); this.win_text = love.graphics.newText(this.win_font, \u0026quot;\u0026quot;); this.x = x; this.y = y; this.padding = padding; } public render() { const win_component = this.read_component(WinDisplayComponent); if (win_component) { this.win_text.set(\u0026quot;Player \u0026quot; + (win_component.player_index + 1) + \u0026quot; wins\u0026quot;); const win_text_width = this.win_text.getWidth(); const win_text_height = this.win_text.getHeight(); love.graphics.setColor(0, 0, 0, 1); love.graphics.rectangle( \u0026quot;fill\u0026quot;, this.x - win_text_width * 0.5 - this.padding, this.y - win_text_height * 0.5 - this.padding, win_text_width + this.padding, win_text_height + this.padding, ); love.graphics.setColor(1, 1, 1, 1); love.graphics.rectangle( \u0026quot;line\u0026quot;, this.x - win_text_width * 0.5 - this.padding, this.y - win_text_height * 0.5 - this.padding, win_text_width + this.padding, win_text_height + this.padding, ); love.graphics.draw( this.win_text, this.x, this.y, 0, 1, 1, this.win_text.getWidth() * 0.5, this.win_text.getHeight() * 0.5, ); } } }  Let\u0026rsquo;s also make it so the ball stops spawning if the game is over. In our BallSpawnTimerEngine component loop:\n... if (this.read_component(WinDisplayComponent)) { this.get_entity(component.entity_id)!.destroy(); continue; } ...  Finally, we\u0026rsquo;re going to need some logic to take us back to the title screen. We could just pass the Game state to a FinishGameEngine\u0026hellip; but then we would have a circular dependency. This is a prime candidate for an Interface.\nLet\u0026rsquo;s create a new folder, game/interfaces and a new file, game/interfaces/finishable.ts:\nexport interface IFinishable { finished: boolean; }  Now, in game/states/game.ts:\nexport class Game extends State implements IFinishable {  Now let\u0026rsquo;s create our FinishGameEngine.\nimport { Engine, Mutates } from \u0026quot;encompass-ecs\u0026quot;; import { FinishGameTimerComponent } from \u0026quot;../components/finish_game_timer\u0026quot;; import { IFinishable } from \u0026quot;../interfaces/finishable\u0026quot;; @Mutates(FinishGameTimerComponent) export class FinishGameEngine extends Engine { private game_state: IFinishable; public initialize(game_state: IFinishable) { this.game_state = game_state; } public update(dt: number) { const finish_game_timer_component = this.read_component_mutable(FinishGameTimerComponent); if (finish_game_timer_component) { finish_game_timer_component.time_remaining -= dt; if (finish_game_timer_component.time_remaining \u0026lt;= 0) { this.game_state.finished = true; } } } }  This is pretty straightforward. Once the timer expires we change the game state to let the rest of the program know the state is finished. Now we can use this in our main loop. In main.ts:\nlove.update = (dt) =\u0026gt; { if (current_state === title) { if (love.keyboard.isDown(\u0026quot;space\u0026quot;)) { current_state = game; } } else if (current_state === game) { if (game.finished) { game = new Game(); game.load(); current_state = title; } } current_state.update(dt); };  Now when the game is finished, it creates a new Game and switches the current state back to the title menu.\nDon\u0026rsquo;t forget to add our new Engines to the WorldBuilder.\nworld_builder.add_engine(CheckScoreEngine).initialize(winning_score); world_builder.add_engine(WinEngine); world_builder.add_engine(FinishGameEngine).initialize(this); world_builder.add_engine(WinRenderer).initialize(play_area_width * 0.5, play_area_height * 0.5, 20);   That\u0026rsquo;s it\u0026hellip; we\u0026rsquo;re done.\n"
},
{
	"uri": "/pong/scoring/tracking_score/",
	"title": "Tracking the Score",
	"tags": [],
	"description": "",
	"content": "Finally, we need to track the score and update it appropriately.\nI think a scoring Component is appropriate.\nimport { Component } from \u0026quot;encompass-ecs\u0026quot;; export class ScoreComponent extends Component { public score: number; }  We should have two different scores, and they should update based on which specific goal is touched by the ball.\nI think we need another tag component.\nimport { Component } from \u0026quot;encompass-ecs\u0026quot;; export class GoalOneComponent extends Component {}  import { Component } from \u0026quot;encompass-ecs\u0026quot;; export class GoalTwoComponent extends Component {}  I know what you\u0026rsquo;re thinking. Why not just have one GoalComponent with an index on it? Encompass lets us retrieve components from the game state by type, and it does so very quickly, so it is good to create structures that let us use that feature. Consider:\nconst goal_one_component = this.read_component(GoalOneComponent);  vs.\nconst goal_components = this.read_components(GoalComponent); let goal_component; for (const component of goal_components.values()) { if (component.goal_index === 1) { goal_component = component; break; } }  The second one is way worse to read right? It\u0026rsquo;s also much slower, performance-wise. Make use of Encompass\u0026rsquo;s component retrieval structure wherever you can.\nYou know the drill by now.\nLet\u0026rsquo;s add a new property to our GoalSpawnMessage so we can tell which one is which.\npublic goal_index: number;  Let\u0026rsquo;s add this in our GoalSpawner:\nconst score_component = entity.add_component(ScoreComponent); score_component.score = 0; if (message.goal_index === 0) { entity.add_component(GoalOneComponent); } else if (message.goal_index === 1) { entity.add_component(GoalTwoComponent); }  Now, we can tell which goal needs to have its score updated.\nLet\u0026rsquo;s create a score update message.\nIn game/messages/score.ts:\nimport { ComponentMessage, Message } from \u0026quot;encompass-ecs\u0026quot;; import { ScoreComponent } from \u0026quot;game/components/score\u0026quot;; export class ScoreMessage extends Message implements ComponentMessage { public component: Readonly\u0026lt;ScoreComponent\u0026gt;; public delta: number; }  Now we can update our BallGoalCollisionEngine.\nconst score_component = message.goal_entity.get_component(ScoreComponent); const score_message = this.emit_component_message(ScoreMessage, score_component); score_message.delta = 1;  And let\u0026rsquo;s create an engine to update the score.\nIn game/engines/score.ts:\nimport { Engine, Mutates, Reads } from \u0026quot;encompass-ecs\u0026quot;; import { ScoreComponent } from \u0026quot;game/components/score\u0026quot;; import { ScoreMessage } from \u0026quot;game/messages/score\u0026quot;; @Reads(ScoreMessage) @Mutates(ScoreComponent) export class ScoreEngine extends Engine { public update() { for (const score_message of this.read_messages(ScoreMessage).values()) { const score_component = this.make_mutable(score_message.component); score_component.score += score_message.delta; } } }  And add it to our WorldBuilder:\nworld_builder.add_engine(ScoreEngine);  Last, but not least, it would be nice to actually see the score being drawn on the screen.\n"
},
{
	"uri": "/pong/move_paddle/decoupling/",
	"title": "Decoupling",
	"tags": [],
	"description": "",
	"content": "There\u0026rsquo;s more to decoupling than just objects not directly referencing each other.\nReally, when we talk about decoupling, we are saying that we don\u0026rsquo;t want the structure of the program having unnecessary direct connections.\nThis is a pretty abstract principle, but there is a nice illustration of it in our program as it exists right now.\nRight now our InputEngine is sending Messages to our MotionEngine. Is that actually what we want?\nWhat I am saying is\u0026hellip; can you think of an example where something other than direct input might want to control the movement of a paddle?\nWhat about AI? What about an \u0026ldquo;attract mode\u0026rdquo;?\nThere\u0026rsquo;s also a lot of structure about the paddle entity being embedded into the logic of the InputEngine. That doesn\u0026rsquo;t feel good to me either.\nLet\u0026rsquo;s put something in between them.\nWe have to ask ourselves: how is it that we want the game to react when we press the buttons? We want the correct paddle to move up or down. That seems like a good abstraction for a Message.\nCreate a file: game/engines/paddle_move_up.ts\nimport { ComponentMessage, Message } from \u0026quot;encompass-ecs\u0026quot;; import { PlayerComponent } from \u0026quot;game/components/player\u0026quot;; export class PaddleMoveUpMessage extends Message implements ComponentMessage { public component: Readonly\u0026lt;PlayerOneComponent\u0026gt;; }  and a file: game/messages/paddle_move_down.ts\nimport { ComponentMessage, Message } from \u0026quot;encompass-ecs\u0026quot;; import { PlayerComponent } from \u0026quot;game/components/player\u0026quot;; export class PaddleMoveDownMessage extends Message implements ComponentMessage { public component: Readonly\u0026lt;PlayerOneComponent\u0026gt;; }  Uh oh, something seems weird here too. Why PlayerOneComponent? Sounds like we need some abstraction.\nCreate a file: game/components/player.ts\nimport { Component } from \u0026quot;encompass-ecs\u0026quot;; export abstract class PlayerComponent extends Component {}  abstract means that the class cannot be used directly, but must be inherited.\nChange games/component/player_one.ts:\nimport { PlayerComponent } from \u0026quot;./player\u0026quot;; export class PlayerOneComponent extends PlayerComponent {}  And create games/component/player_two.ts:\nimport { PlayerComponent } from \u0026quot;./player\u0026quot;; export class PlayerTwoComponent extends PlayerComponent {}  One more thing: Why do we have separate MoveUp and MoveDown messages? The only distinction is the direction, which can easily be represented by a number. Let\u0026rsquo;s consolidate everything.\nDelete our PaddleMoveUpMessage and PaddleMoveDownMessage.\nCreate a file: game/messages/paddle_move.ts\nimport { ComponentMessage, Message } from \u0026quot;encompass-ecs\u0026quot;; import { PlayerComponent } from \u0026quot;game/components/player\u0026quot;; export class PaddleMoveMessage extends Message implements ComponentMessage { public component: Readonly\u0026lt;PlayerComponent\u0026gt;; public direction: number; }  Now we\u0026rsquo;re ready to rumble!!\nCreate a file: game/engines/paddle_movement.ts\nimport { Emits, Engine, Reads } from \u0026quot;encompass-ecs\u0026quot;; import { PaddleMoveSpeedComponent } from \u0026quot;game/components/paddle_move_speed\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; import { MotionMessage } from \u0026quot;game/messages/component/motion\u0026quot;; import { PaddleMoveMessage } from \u0026quot;game/messages/component/paddle_move\u0026quot;; @Reads(PaddleMoveMessage) @Emits(MotionMessage) export class PaddleMovementEngine extends Engine { public update() { for (const message of this.read_messages(PaddleMoveMessage).values()) { const player_component = message.component; const player_entity = this.get_entity(player_component.entity_id); if (player_entity) { const position_component = player_entity.get_component(PositionComponent); const move_speed_component = player_entity.get_component(PaddleMoveSpeedComponent); const motion_message = this.emit_component_message(MotionMessage, position_component); motion_message.x = 0; motion_message.y = message.direction * move_speed_component.y; } } } }  Finally, we revise our InputEngine to send PaddleMoveMessages.\nimport { Emits, Engine } from \u0026quot;encompass-ecs\u0026quot;; import { PlayerOneComponent } from \u0026quot;game/components/player_one\u0026quot;; import { PaddleMoveMessage } from \u0026quot;game/messages/component/paddle_move\u0026quot;; @Emits(PaddleMoveMessage) export class InputEngine extends Engine { public update() { const player_one_component = this.read_component(PlayerOneComponent); if (player_one_component) { const player_one_entity = this.get_entity(player_one_component.entity_id); if (player_one_entity) { if (love.keyboard.isDown(\u0026quot;up\u0026quot;)) { const message = this.emit_component_message(PaddleMoveMessage, player_one_component); message.direction = -1; } else if (love.keyboard.isDown(\u0026quot;down\u0026quot;)) { const message = this.emit_component_message(PaddleMoveMessage, player_one_component); message.direction = 1; } } } } }  And don\u0026rsquo;t forgot to add our new Engine to the WorldBuilder.\nworld_builder.add_engine(PaddleMovementEngine);  Look at how concise and easy to understand everything is now! And when we get around to adding Player 2 we\u0026rsquo;ll barely have to do any work at all, because everything that drives Player 1 can be used to drive Player 2.\nDecoupling isn\u0026rsquo;t just a law we follow just because someone told us it was a good idea or whatever. It exists as a principle to remind us to try to express our ideas at a higher level, so we can write more powerful and concise code and create less room for error.\nWhen you get more experienced you\u0026rsquo;ll be able to sniff out tightly coupled code very easily. Don\u0026rsquo;t stress about it too much, but keep the idea in the back of your mind always.\nBefore we move on, let\u0026rsquo;s make the paddle a little zippier.\nmove_speed_component.y = 400;   That\u0026rsquo;s more like it.\n"
},
{
	"uri": "/concepts/renderer/",
	"title": "Renderer",
	"tags": [],
	"description": "",
	"content": "A Renderer is responsible for reading the game state and telling the game engine what to draw to the screen.\nRemember: Encompass isn\u0026rsquo;t a game engine and it doesn\u0026rsquo;t have a rendering system. So Renderers aren\u0026rsquo;t actually doing the rendering, they\u0026rsquo;re just telling the game engine what to render.\n There are two kinds of renderers: GeneralRenderers and EntityRenderers.\nA GeneralRenderer is a Renderer which reads the game state in order to draw elements to the screen. It also requires a layer, which represents the order in which it will draw to the screen.\nIf you were using the LOVE engine, a GeneralRenderer might look like this:\nimport { GeneralRenderer } from \u0026quot;encompass-ecs\u0026quot;; import { ScoreComponent } from \u0026quot;game/components/score\u0026quot;; export class ScoreRenderer extends GeneralRenderer { public layer = 4; public render() { const score_component = this.read_component(ScoreComponent); love.graphics.print(score_component.score, 20, 20); } }  An EntityRenderer provides a structure for the common pattern of drawing an Entity which has a particular collection of Components and a specific type of DrawComponent. They also have the ability to draw DrawComponents at their specific layer.\nIf you were using the LOVE engine, a GeneralRenderer might look like this:\nimport { EntityRenderer } from \u0026quot;encompass-ecs\u0026quot;; import { PointComponent } from \u0026quot;game/components/point\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; @Renders(PointComponent, PositionComponent) export class PointRenderer extends EntityRenderer { public render(entity: Entity) { const point_component = entity.get_component(PointComponent); const position_component = entity.get_component(PositionComponent); const color = point_component.color; love.graphics.setColor(color.r, color.g, color.b, color.a); love.graphics.point(position_component.x, position_component.y); } }  For 2D games, you will need to use layers to be specific about the order in which entities draw. For a 3D game you will probably end up delegating rendering to some kind of scene/camera system.\n"
},
{
	"uri": "/why/architecture/hyper_ecs/",
	"title": "Hyper ECS",
	"tags": [],
	"description": "",
	"content": "Hyper ECS is a new architecture pattern that attempts to address some common issues with standard ECS. This is the architecture that Encompass implements.\nThe core of the architecture is the introduction of a new construct to ECS: the Message.\nA Message is fundamentally a variant of Component, in that it only contains data. But, it is designed to be temporary and is discarded at the end of each frame. It is used to communicate useful information between Systems.\nWe also introduce some extra information to Systems. Each System must declare the Messages that it Reads, the Messages that it Emits, and the Components that it Mutates.\nLet\u0026rsquo;s go back to our earlier example.\nWe have TransformComponent, which contains position and orientation data, and VelocityComponent, which contains an x and y component for linear motion.\nOur MotionDetecterSystem reads each Entity that has both a TransformComponent and a VelocityComponent, and emits a MotionMessage, which contains a reference to the specific TransformComponent and the x and y velocity given by the VelocityComponent.\nWe also have a TeleportSystem that needs to teleport the character forward a bit. Let\u0026rsquo;s say when the player presses the X button, a TeleportMessage is fired. The TeleportSystem reads this message and emits a MotionMessage in response.\nNow we have our MotionSystem. The MotionSystem declares that it Mutates the TransformComponent, reads the MotionMessages that apply to each TransformComponent, and applies them simultaneously, adding their x and y values to the TransformComponent. Voilà! No race conditions! And we can re-use similar behaviors easily without re-writing code by consolidating Messages.\nYou might be wondering: how does the game know which order these systems need to be in? Well\u0026hellip;\nHyper ECS figures it out for you.\nThat\u0026rsquo;s right! With the power of graph theory, we can construct an order for our Systems so that any System which Emits a certain Message runs before any System that Reads the same Message. This means, when you write behavior for your game, you never have to specify the order in which your Systems run. You simply write code, and the Systems run in a valid order, every time, without surprising you.\nOf course, to accomplish this, there are some restrictions that your Systems must follow.\nSystems are not allowed to create message cycles. If System A emits Message B, which is read by System B which emits Message C, which is read by System A, then we cannot create a valid ordering of Systems. This is not a flaw in the architecture: A message cycle is simply evidence that you haven\u0026rsquo;t quite thought through what your Systems are doing, and can generally be easily eliminated by the introduction of a new System.\nTwo separate systems are not allowed to Mutate the same Component. Obviously, if we allowed this, we would introduce the possibility of two Systems changing the same component, creating a race condition. If we have two Systems where it makes sense to change the same Component, we can create a new Message and System to consolidate the changes, and avoid race conditions.\nIf you are used to programming games in an object-oriented way, you will likely find the ECS pattern counter-intuitive at first. But once you learn to think in a Hyper ECS way, you will be shocked at how flexible and simple your programs become.\n"
},
{
	"uri": "/concepts/world_builder/",
	"title": "World Builder",
	"tags": [],
	"description": "",
	"content": "WorldBuilder is used to construct a World from Engines, Renderers, and an initial state of Entities, Components, and Messages.\nThe WorldBuilder enforces certain rules about Engine structure. It is forbidden to have messages create cycles between Engines, and no Component may be mutated by more than one Engine.\nThe WorldBuilder uses Engines and their Message read/emit information to determine a valid ordering of the Engines, which is given to the World.\nHere is an example usage:\nimport { WorldBuilder } from \u0026quot;encompass-ecs\u0026quot;; import { CanvasComponent } from \u0026quot;./components/canvas\u0026quot;; import { PositionComponent } from \u0026quot;./components/position\u0026quot;; import { VelocityComponent } from \u0026quot;./components/velocity\u0026quot;; import { MotionEngine } from \u0026quot;./engines/motion\u0026quot;; import { CanvasRenderer } from \u0026quot;./renderers/canvas\u0026quot;; class Game { private World world; ... public load() { const world_builder = new WorldBuilder(); world_builder.add_engine(MotionEngine); world_builder.add_renderer(CanvasRenderer); const entity = world_builder.create_entity(); const position_component = entity.add_component(PositionComponent); position_component.x = 0; position_component.y = 0; const velocity_component = entity.add_component(VelocityComponent); velocity_component.x = 20; velocity_component.y = 0; const sprite_component = entity.add_component(SpriteComponent); canvas_component.canvas = love.graphics.newImage(\u0026quot;assets/sprites/ball.png\u0026quot;); this.world = world_builder.build(); } ... }  Now our game will initialize with a ball that moves horizontally across the screen!\nTip\nMake sure that you remember to add Engines to the WorldBuilder when you define them. Otherwise nothing will happen, which can be very embarrassing.\n "
},
{
	"uri": "/pong/scoring/drawing_score/",
	"title": "Drawing the Score",
	"tags": [],
	"description": "",
	"content": "Remember Renderers? Haven\u0026rsquo;t thought about those in a while.\nAll we need to draw new elements to the screen are Renderers. Let\u0026rsquo;s create a new GeneralRenderer.\nBut first, we\u0026rsquo;re gonna need a font. I liked this font. But you can pick any font you like. It\u0026rsquo;s your world and you can do whatever you like in it.\nPlace the font of your heart\u0026rsquo;s desire into the directory game/assets/fonts. Then it can be used in your game.\nLet\u0026rsquo;s write our ScoreRenderer.\nIn game/renderers/score.ts:\nimport { Component, GeneralRenderer, Type } from \u0026quot;encompass-ecs\u0026quot;; import { GoalOneComponent } from \u0026quot;game/components/goal_one\u0026quot;; import { GoalTwoComponent } from \u0026quot;game/components/goal_two\u0026quot;; import { ScoreComponent } from \u0026quot;game/components/score\u0026quot;; export class ScoreRenderer extends GeneralRenderer { public layer = 1; private midpoint: number; private score_font: Font; private player_one_score_text: Text; private player_two_score_text: Text; public initialize(midpoint: number) { this.midpoint = midpoint; this.score_font = love.graphics.newFont(\u0026quot;game/assets/fonts/Squared Display.ttf\u0026quot;, 128); this.player_one_score_text = love.graphics.newText(this.score_font, \u0026quot;0\u0026quot;); this.player_two_score_text = love.graphics.newText(this.score_font, \u0026quot;0\u0026quot;); } public render() { this.render_score(GoalTwoComponent, this.player_two_score_text, this.midpoint - 200, 30); this.render_score(GoalOneComponent, this.player_one_score_text, this.midpoint + 200, 30); } private render_score(ComponentType: Type\u0026lt;Component\u0026gt;, score_text: Text, x: number, y: number) { const goal_component = this.read_component(ComponentType); if (goal_component) { const entity = this.get_entity(goal_component.entity_id); if (entity) { const score_component = entity.get_component(ScoreComponent); if (score_component) { score_text.set(score_component.score.toString()); love.graphics.draw( score_text, x, y, 0, 1, 1, score_text.getWidth() * 0.5, score_text.getHeight() * 0.5, ); } } } } }  Basically, we find each goal component, grab its score component, and draw the score component\u0026rsquo;s value to the screen as text.\nIf we create new LOVE Text object every frame, this is very performance heavy. So we want to create a Text on initialization and then set its contents instead.\nIt\u0026rsquo;s also very expensive to create a new LOVE Font every frame. Like the Text objects, we store it on the Renderer.\nLet\u0026rsquo;s add our ScoreRenderer to the WorldBuilder.\nworld_builder.add_renderer(ScoreRenderer).initialize(play_area_width * 0.5);   Look at that! It\u0026rsquo;s starting to look and feel like a more complete game now.\n"
},
{
	"uri": "/pong/scoring/center_line/",
	"title": "Center Line",
	"tags": [],
	"description": "",
	"content": "Now we need to draw the center line.\nThis will be a fairly basic GeneralRenderer - it doesn\u0026rsquo;t need to react to anything.\nimport { GeneralRenderer } from \u0026quot;encompass-ecs\u0026quot;; export class CenterLineRenderer extends GeneralRenderer { public layer = 0; private middle: number; private height: number; public initialize(middle: number, height: number) { this.middle = middle; this.height = height; } public render() { love.graphics.setLineWidth(2); this.dotted_line(this.middle, 0, this.middle, this.height, 10, 10); } private dotted_line(x1: number, y1: number, x2: number, y2: number, dash: number, gap: number) { const dx = x2 - x1; const dy = y2 - y1; const angle = math.atan2(dy, dx); const st = dash + gap; const len = math.sqrt(dx * dx + dy * dy); const nm = (len - dash) / st; love.graphics.push(); love.graphics.translate(x1, y1); love.graphics.rotate(angle); for (let i = 0; i \u0026lt; nm; i++) { love.graphics.line(i * st + gap * 0.5, 0, i * st + dash + gap * 0.5, 0); } love.graphics.pop(); } }  I took the dotted line draw procedure from this helpful forum post and modified it slightly. Thanks Ref!\nAdd it to the WorldBuilder\u0026hellip;\nworld_builder.add_renderer(CenterLineRenderer).initialize(play_area_width * 0.5, play_area_height);  "
},
{
	"uri": "/pong/ball/bouncing/",
	"title": "Bouncing",
	"tags": [],
	"description": "",
	"content": "Let\u0026rsquo;s make the ball bounce off the sides of the game window.\nI know what you\u0026rsquo;re thinking. \u0026ldquo;Let\u0026rsquo;s just read the dimensions of the game window. When the ball goes past them, we know it should bounce!\u0026rdquo;\nNO.\nWe don\u0026rsquo;t want the behavior of any object to be directly tied to some state outside of the game simulation. That\u0026rsquo;s just asking for trouble!! What if you want the game boundaries to be different from the window size later? What if a different device has different dimensions? The possibilities are endless!\nThere\u0026rsquo;s something else going on here too: eventually we\u0026rsquo;re gonna need the ball to bounce off of the paddles as well right? I think what we really need here is a collision system.\nAll of our objects are rectangles so I think a simple AABB (axis-aligned bounding box) check will suffice. Essentially we just use non-rotating rectangles and check if they are overlapping.\nHang on a sec though - this is a pretty standard problem right? Pretty much every game in existence uses collision detection.\nLOVE provides a physics system under love.physics. But it\u0026rsquo;s actually a fully featured physics simulator that attempts to behave realistically under physical constraints. It\u0026rsquo;s a little heavy to use it just for simple collision detection and we\u0026rsquo;d probably have to rework all of our entities and components to integrate it properly at this point.\nTurns out that there is a library for AABB collision that will work just fine for our purposes. It\u0026rsquo;s called bump.lua. Let\u0026rsquo;s start by integrating it.\n"
},
{
	"uri": "/pong/move_paddle/",
	"title": "Moving the Paddle",
	"tags": [],
	"description": "",
	"content": "Now we want to drive the simulation: we want values to change over time.\nSo we are gonna need some Engines.\nLet\u0026rsquo;s write our first Engine.\n"
},
{
	"uri": "/concepts/world/",
	"title": "World",
	"tags": [],
	"description": "",
	"content": "World is the pie crust that contains all the delicious Encompass ingredients together.\nThe World\u0026rsquo;s update function drives the simulation and should be controlled from your engine\u0026rsquo;s update loop.\nThe World\u0026rsquo;s draw function tells the Renderers to draw the scene.\nIn LÖVE, the starter project game loop looks like this:\nexport class Game { private world: World; private canvas: Canvas; ... public update(dt: number) { this.world.update(dt); } public draw() { love.graphics.clear(); love.graphics.setCanvas(this.canvas); love.graphics.clear(); this.world.draw(); love.graphics.setCanvas(); love.graphics.setBlendMode(\u0026quot;alpha\u0026quot;, \u0026quot;premultiplied\u0026quot;); love.graphics.setColor(1, 1, 1, 1); love.graphics.draw(this.canvas); } }  But you can call these methods wherever you see fit.\nTip\nCertain Encompass projects actually have multiple separate Worlds to manage certain behaviors. This is perfectly valid and can be a great way to structure your project, but be warned that it is difficult to share information between Worlds by design.\n What\u0026rsquo;s that whole dt business about?\ndt stands for delta-time. Correct usage of delta-time is crucial to make sure that your game does not become frame-dependent, which is very bad. We\u0026rsquo;ll talk more about frame-dependence later in the tutorial, but to briefly summarize, if your game is frame-dependent you will run into very frustrating behavior when running your game on different computer systems.\nThat\u0026rsquo;s it! Now that we have these high-level concepts down, let\u0026rsquo;s build an actual, for-real game.\n"
},
{
	"uri": "/pong/ball/",
	"title": "Ball",
	"tags": [],
	"description": "",
	"content": "Pong isn\u0026rsquo;t much without a ball. Let\u0026rsquo;s get started on that.\nFortunately there is a lot of stuff we can re-use already. That\u0026rsquo;s the power of Encompass!\n"
},
{
	"uri": "/pong/ball/bouncing/design/",
	"title": "Design",
	"tags": [],
	"description": "",
	"content": "Now we have a way to tell when objects are colliding. Let\u0026rsquo;s make something happen as a result!\nFirst, let\u0026rsquo;s think about the structure of a collision system, and how we want it to resolve collisions.\nOne thing we really don\u0026rsquo;t want is for collision to resolve late. For example, a frame finishing with two solid objects lodged inside each other, and then fixing itself on the next frame. Even if it\u0026rsquo;s only for a frame, it\u0026rsquo;s enough for players to detect some awkwardness.\nWe also need objects to behave differently based on what they collide with. For example, a ball colliding with the top boundary is going to react differently than if it collides with a goal boundary.\nFor this reason, I think it makes sense to define each object as having a CollisionType; in our game a colliding object is always either a ball, a wall, or a paddle. We can implement different behaviors for a ball-wall, ball-paddle, or paddle-wall collision.\nYou might think it would be better to determine collision behavior by placing collision behavior components on the entities. This feels awkward to me, but I could definitely be wrong about this. If you want to try doing things that way, the power is yours! Just make sure you have a good justification for it.\nYou might remember that we can only modify a component in one engine. So we\u0026rsquo;re going to have to be deliberate about this.\nHere\u0026rsquo;s what I\u0026rsquo;m thinking:\n Tell things to move Calculate the position they would potentially move to Use that position to check collision Do stuff in response to collision, including telling things to move again Resolve all the movements  We already have MotionMessages. Let\u0026rsquo;s keep those, but redirect them slightly. We can\u0026rsquo;t read MotionMessages and then Emit them again later down the line: that would cause a cycle. So let\u0026rsquo;s have a new UpdatePositionMessage.\nLet\u0026rsquo;s have the MotionEngine consolidate all the MotionMessages per-component, send out an UpdatePositionMessage with that final delta, but then also send out a CollisionCheckMessage for everything that has a BoundingBoxComponent.\nFinally, a CollisionDispatchEngine figures out what two kinds of objects collided and emits a Message in response. We can then implement various collision resolution Engines that read each of those kinds of Messages. For example, a BallWallCollisionMessage would be handled by a BallWallCollisionEngine.\ngraph TD; Engines(Various Engines) --|MotionMessage| MotionEngine[MotionEngine] MotionEngine --|CollisionCheckMessage| CollisionCheckEngine[CollisionCheckEngine] CollisionCheckEngine --|CollisionMessage| CollisionDispatchEngine[CollisionDispatchEngine] CollisionDispatchEngine --|BallWallCollisionMessage| BallWallCollisionEngine[BallWallCollisionEngine] CollisionDispatchEngine --|BallPaddleCollisionMessage| BallPaddleCollisionEngine[BallPaddleCollisionEngine] BallWallCollisionEngine --|UpdatePositionMessage| UpdatePositionEngine BallPaddleCollisionEngine --|UpdatePositionMessage| UpdatePositionEngine MotionEngine --|UpdatePositionMessage| UpdatePositionEngine  Whew! That\u0026rsquo;s a lot! You might be wondering why we\u0026rsquo;re doing all this work just to get some objects reacting to each other.\nThe thing is: this kind of thing is the backbone of many game designs. So of course it\u0026rsquo;s a bit complex! The point is that there\u0026rsquo;s no point obscuring the complexity of such a system or putting off thinking about it until later. If we build our project on a shoddy foundation we will surely have problems later. Let\u0026rsquo;s get a robust system in there so we don\u0026rsquo;t have to fundamentally reorganize our program at a later time, when it will be more frustrating and have more potential to break things.\nLet\u0026rsquo;s get started.\n"
},
{
	"uri": "/notes/",
	"title": "Notes",
	"tags": [],
	"description": "",
	"content": " Appendix A Notes Some odds and ends.\n"
},
{
	"uri": "/pong/opponent/",
	"title": "The Opponent",
	"tags": [],
	"description": "",
	"content": "Now that we have the ball moving around and bouncing, let\u0026rsquo;s get the computer-controlled paddle working. We already have a lot of tools available to us from our implementation of the player paddle, so let\u0026rsquo;s re-use as much as we can.\nThe computer-controlled paddle is essentially the same as the player-controlled paddle. The only difference is what causes it to move. So here\u0026rsquo;s what we need to do.\n Designate in the PaddleSpawnMessage what is controlling the paddle Implement an engine that sends PaddleMoveMessages to the paddle  Let\u0026rsquo;s revise our PaddleSpawnMessage. An enum type for our paddle control seems appropriate here.\nimport { Message } from \u0026quot;encompass-ecs\u0026quot;; export enum PaddleControlType { player_one, computer, } export class PaddleSpawnMessage extends Message { public x: number; public y: number; public width: number; public height: number; public move_speed: number; public control_type: PaddleControlType; }  Then in the PaddleSpawner, where we add the PlayerOneComponent, let\u0026rsquo;s put this instead:\nif (message.control_type === PaddleControlType.player_one) { paddle_entity.add_component(PlayerOneComponent); } else if (message.control_type === PaddleControlType.computer) { paddle_entity.add_component(PlayerComputerComponent); }  Now we can move on to the actual computer control behavior. The behavior of the Pong computer is pretty simple - it just moves the paddle towards the y position of the ball.\nWe don\u0026rsquo;t actually have a way to get the ball from the game state yet, so let\u0026rsquo;s make another marker component.\nIn game/components/ball.ts:\nimport { Component } from \u0026quot;encompass-ecs\u0026quot;; export class BallComponent extends Component {}  and in our BallSpawner:\nball_entity.add_component(BallComponent);  Now let\u0026rsquo;s make our ComputerControlEngine. It will read the state of the game and tell the paddle to move in the direction of the ball.\nIn game/engines/computer_control.ts:\nimport { Emits, Engine } from \u0026quot;encompass-ecs\u0026quot;; import { BallComponent } from \u0026quot;game/components/ball\u0026quot;; import { PlayerComputerComponent } from \u0026quot;game/components/player_computer\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; import { PaddleMoveMessage } from \u0026quot;game/messages/component/paddle_move\u0026quot;; @Emits(PaddleMoveMessage) export class ComputerControlEngine extends Engine { public update() { const computer_components = this.read_components(PlayerComputerComponent); const ball_component = this.read_component(BallComponent); if (!ball_component) { return; } const ball_entity = this.get_entity(ball_component.entity_id); if (!ball_entity) { return; } const ball_position = ball_entity.get_component(PositionComponent); for (const computer_component of computer_components.values()) { const computer_entity = this.get_entity(computer_component.entity_id); if (computer_entity) { const computer_position = computer_entity.get_component(PositionComponent); if (computer_position.y - ball_position.y \u0026gt; 40) { const message = this.emit_component_message(PaddleMoveMessage, computer_component); message.direction = -1; } else if (computer_position.y - ball_position.y \u0026lt; -40) { const message = this.emit_component_message(PaddleMoveMessage, computer_component); message.direction = 1; } } } } }  Notice how we are being careful not to assume the ball actually exists in this code. Remember - it never hurts to check if an object actually exists! You might save yourself from a nasty crash.\nDon\u0026rsquo;t forget to add the new Engine in game.ts!\nworld_builder.add_engine(ComputerControlEngine);   If we were doing this in an object-oriented way, we would have had to inherit from the paddle or introduce another state to the paddle, thus forcing us to refactor or increase the complexity of the paddle object itself.\nNotice how in our case we didn\u0026rsquo;t really have to change any of our existing logic - all we had to do was create a new component and write a new engine for producing behavior from that component, while getting to retain all the behavior we got from the other paddle components. See how clean and de-coupled this is? This is the power of composition over inheritance.\n"
},
{
	"uri": "/pong/ball/bouncing/motion_engine/",
	"title": "Motion Engine: The Revenge",
	"tags": [],
	"description": "",
	"content": "Here\u0026rsquo;s the process we\u0026rsquo;ll follow for our MotionEngine:\nWe associate MotionMessages with their PositionComponents. We consolidate them to get a total \u0026ldquo;x_delta\u0026rdquo; and a \u0026ldquo;y_delta\u0026rdquo;. We create an UpdatePositionMessage containing these values. Next, we create CollisionCheckMessages containing the delta values if the PositionComponent\u0026rsquo;s entity has a BoundingBoxComponent.\nFinally, we go over all BoundingBoxComponents that didn\u0026rsquo;t have MotionMessages associated with them and create CollisionCheckMessages for those too. Otherwise things that didn\u0026rsquo;t move wouldn\u0026rsquo;t be collision checked, and that would not be correct.\nIn game/messages/collision_check.ts:\nimport { Entity, Message } from \u0026quot;encompass-ecs\u0026quot;; export class CollisionCheckMessage extends Message { public entity: Entity; public x_delta: number; public y_delta: number; }  In game/messages/update_position.ts:\nimport { ComponentMessage, Message } from \u0026quot;encompass-ecs\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; export class UpdatePositionMessage extends Message implements ComponentMessage { public component: Readonly\u0026lt;PositionComponent\u0026gt;; public x_delta: number; public y_delta: number; }  Let\u0026rsquo;s rewrite our MotionEngine.\nimport { Emits, Engine, Reads } from \u0026quot;encompass-ecs\u0026quot;; import { BoundingBoxComponent } from \u0026quot;game/components/bounding_box\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; import { CollisionCheckMessage } from \u0026quot;game/messages/collision_check\u0026quot;; import { MotionMessage } from \u0026quot;game/messages/component/motion\u0026quot;; import { UpdatePositionMessage } from \u0026quot;game/messages/update_position\u0026quot;; import { GCOptimizedList, GCOptimizedSet } from \u0026quot;encompass-gc-optimized-collections\u0026quot;; @Reads(MotionMessage) @Emits(UpdatePositionMessage, CollisionCheckMessage) export class MotionEngine extends Engine { private component_to_message = new Map\u0026lt;PositionComponent, GCOptimizedList\u0026lt;MotionMessage\u0026gt;\u0026gt;(); private bounding_box_set = new GCOptimizedSet\u0026lt;BoundingBoxComponent\u0026gt;(); public update(dt: number) { const motion_messages = this.read_messages(MotionMessage); for (const message of motion_messages.values()) { this.register_message(message); } for (const [position_component, messages] of this.component_to_message.entries()) { const entity = this.get_entity(position_component.entity_id)!; let x_delta = 0; let y_delta = 0; for (const message of messages.values()) { x_delta += message.x * dt; y_delta += message.y * dt; } const update_position_message = this.emit_component_message(UpdatePositionMessage, position_component); update_position_message.x_delta = x_delta; update_position_message.y_delta = y_delta; if (entity.has_component(BoundingBoxComponent)) { const collision_check_message = this.emit_message(CollisionCheckMessage); collision_check_message.entity = entity; collision_check_message.x_delta = x_delta; collision_check_message.y_delta = y_delta; this.bounding_box_set.add(entity.get_component(BoundingBoxComponent)); } } for (const component of this.read_components(BoundingBoxComponent).values()) { if (!this.bounding_box_set.has(component)) { const collision_check_message = this.emit_message(CollisionCheckMessage); collision_check_message.entity = this.get_entity(component.entity_id)!; collision_check_message.x_delta = 0; collision_check_message.y_delta = 0; } } this.component_to_message.clear(); } private register_message(message: MotionMessage) { if (!this.component_to_message.has(message.component)) { this.component_to_message.set(message.component, new GCOptimizedList\u0026lt;MotionMessage\u0026gt;()); } this.component_to_message.get(message.component)!.add(message); } }  Now let\u0026rsquo;s detect collisions.\n"
},
{
	"uri": "/pong/ball/bouncing/collision_checking/",
	"title": "Collision Checking",
	"tags": [],
	"description": "",
	"content": "In game/engines/collision_message.ts:\nimport { Entity, Message } from \u0026quot;encompass-ecs\u0026quot;; import { CollisionType } from \u0026quot;game/components/collision_types\u0026quot;; import { Collision } from \u0026quot;lua-lib/bump\u0026quot;; export class CollisionMessage extends Message { public entity_one: Entity; public entity_two: Entity; public collision_type_one: CollisionType; public collision_type_two: CollisionType; public entity_one_new_x: number; public entity_one_new_y: number; public entity_two_new_x: number; public entity_two_new_y: number; public collision_data: Collision; }  Let\u0026rsquo;s break down what we want collision detection to actually do.\nFirst, we tell the Collision World about the current positions of the objects. Next we check each object for collisions by using the \u0026ldquo;check\u0026rdquo; method, which takes the proposed new position of the object and gives us collision information in return.\nFor every collision that we find, we create a CollisionMessage for it.\nIn game/engines/collision_check.ts:\nimport { Emits, Engine, Entity, Reads } from \u0026quot;encompass-ecs\u0026quot;; import { BoundingBoxComponent } from \u0026quot;game/components/bounding_box\u0026quot;; import { CollisionTypesComponent } from \u0026quot;game/components/collision_types\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; import { CollisionMessage } from \u0026quot;game/messages/collision\u0026quot;; import { CollisionCheckMessage } from \u0026quot;game/messages/collision_check\u0026quot;; import { World } from \u0026quot;lua-lib/bump\u0026quot;; @Reads(CollisionCheckMessage) @Emits(CollisionMessage) export class CollisionCheckEngine extends Engine { private collision_world: World; public initialize(collision_world: World) { this.collision_world = collision_world; } public update() { const collision_check_messages = this.read_messages(CollisionCheckMessage); // update all positions in collision world for (const message of collision_check_messages.values()) { const entity = message.entity; const position = entity.get_component(PositionComponent); const bounding_box = entity.get_component(BoundingBoxComponent); this.collision_world.update( message.entity, position.x - bounding_box.width * 0.5, position.y - bounding_box.height * 0.5 ); } // perform collision checks with new positions for (const message of collision_check_messages.values()) { const entity = message.entity; const position = entity.get_component(PositionComponent); const bounding_box = entity.get_component(BoundingBoxComponent); const x = position.x + message.x_delta; const y = position.y + message.y_delta; const [new_x, new_y, cols, len] = this.collision_world.check( entity, x - bounding_box.width * 0.5, y - bounding_box.height * 0.5, () =\u0026gt; \u0026quot;touch\u0026quot; ); for (const col of cols) { const other = col.other as Entity; const other_position = other.get_component(PositionComponent); for (const collision_type_one of entity.get_component(CollisionTypesComponent)!.collision_types) { for (const collision_type_two of other.get_component(CollisionTypesComponent)!.collision_types) { const collision_message = this.emit_message(CollisionMessage); if (collision_type_one \u0026lt; collision_type_two) { collision_message.entity_one = entity; collision_message.entity_two = other; collision_message.collision_type_one = collision_type_one; collision_message.collision_type_two = collision_type_two; collision_message.entity_one_new_x = x; collision_message.entity_one_new_y = y; collision_message.entity_two_new_x = other_position.x; collision_message.entity_two_new_y = other_position.y; collision_message.collision_data = col; } else { collision_message.entity_one = other; collision_message.entity_two = entity; collision_message.collision_type_one = collision_type_two; collision_message.collision_type_two = collision_type_one; collision_message.entity_one_new_x = other_position.x; collision_message.entity_one_new_y = other_position.y; collision_message.entity_two_new_x = x; collision_message.entity_two_new_y = y; collision_message.collision_data = col; } } } } } } }  Why are we comparing the collision types? Let\u0026rsquo;s say we want to have a BallWallCollisionMessage. Obviously we will want to know which entity in the collision represents the ball and which one represents the wall. So we just sort them at this step for convenience.\nLet\u0026rsquo;s make sure that our enum is sorted in alphabetical order.\nIn game/components/collision_types.ts:\nexport enum CollisionType { ball, paddle, wall, }  The \u0026ldquo;initialize\u0026rdquo; method gives the Engine a reference to the Collision World that needs to be shared by everything that deals with collision. Let\u0026rsquo;s make sure to call the \u0026ldquo;initialize\u0026rdquo; method from game.ts:\nconst collision_world = CollisionWorld.newWorld(32); ... world_builder.add_engine(CollisionCheckEngine).initialize(collision_world);  "
},
{
	"uri": "/pong/ball/bouncing/collision_dispatch/",
	"title": "Collision Dispatch",
	"tags": [],
	"description": "",
	"content": "Let\u0026rsquo;s make the CollisionDispatchEngine. All it needs to do is read the CollisionMessages and create specific collision messages from them.\nIn games/engines/collision_dispatch.ts:\nimport { Emits, Engine, Reads } from \u0026quot;encompass-ecs\u0026quot;; import { CollisionType } from \u0026quot;game/components/collision_types\u0026quot;; import { CollisionMessage } from \u0026quot;game/messages/collision\u0026quot;; import { BallPaddleCollisionMessage } from \u0026quot;game/messages/collisions/ball_paddle\u0026quot;; import { BallWallCollisionMessage } from \u0026quot;game/messages/collisions/ball_wall\u0026quot;; import { PaddleWallCollisionMessage } from \u0026quot;game/messages/collisions/paddle_wall\u0026quot;; @Reads(CollisionMessage) @Emits(BallPaddleCollisionMessage, BallWallCollisionMessage, PaddleWallCollisionMessage) export class CollisionDispatchEngine extends Engine { public update() { const collision_messages = this.read_messages(CollisionMessage); for (const collision_message of collision_messages.values()) { switch (collision_message.collision_type_one) { case CollisionType.ball: switch (collision_message.collision_type_two) { case CollisionType.paddle: { const message = this.emit_message(BallPaddleCollisionMessage); message.ball_entity = collision_message.entity_one; message.paddle_entity = collision_message.entity_two; message.ball_new_x = collision_message.entity_one_new_x; message.ball_new_y = collision_message.entity_one_new_y; message.normal = collision_message.collision_data.normal; message.touch = collision_message.collision_data.touch; break; } case CollisionType.wall: { const message = this.emit_message(BallWallCollisionMessage); message.ball_entity = collision_message.entity_one; message.wall_entity = collision_message.entity_two; message.ball_new_x = collision_message.entity_one_new_x; message.ball_new_y = collision_message.entity_one_new_y; message.normal = collision_message.collision_data.normal; message.touch = collision_message.collision_data.touch; break; } } break; case CollisionType.paddle: { switch (collision_message.collision_type_two) { case CollisionType.wall: { const message = this.emit_message(PaddleWallCollisionMessage); message.paddle_entity = collision_message.entity_one; message.paddle_new_x = collision_message.entity_one_new_x; message.paddle_new_y = collision_message.entity_one_new_y; message.wall_entity = collision_message.entity_two; message.normal = collision_message.collision_data.normal; message.touch = collision_message.collision_data.touch; break; } } } } } } }  Now we are emitting proper collision messages every time an entity collides with another.\nDon\u0026rsquo;t forget to add our new engine in game.ts\nworld_builder.add_engine(CollisionDispatchEngine);  Clever readers have probably noticed that this is a bit of an awkward structure. For our game, we only have three types of colliding entities we care about, so some switch statements work fine. What about a game with 20 different kinds of colliding entities? 100? We\u0026rsquo;d probably want a much more generic structure or this Engine\u0026rsquo;s complexity would get out of hand.\nWhat you really want to do, fundamentally, is map two collision types, independent of order, to a message emitting function. You\u0026rsquo;ll probably need to implement a custom data structure to do this cleanly. It\u0026rsquo;s very much outside of the scope of this tutorial for me to do this, but I wish you luck!\n Next, we\u0026rsquo;ll make our game actually do things in response to these messages.\n"
},
{
	"uri": "/pong/ball/bouncing/collision_resolution/",
	"title": "Collision Resolution",
	"tags": [],
	"description": "",
	"content": "What do we want to actually happen when a ball collides with a wall?\nObviously the wall doesn\u0026rsquo;t do anything. It just sits there. That\u0026rsquo;s easy!\nThe ball needs to bounce off of the wall. We can calculate exactly where it should end up by adding distance along the collision normal equal to twice the difference between the proposed location of the ball and where it touched the wall.\nTip\nWhat the heck is a collision normal?\nYou can think of the collision normal as just an arrow pointing away from the wall. If you want more details about this, check out the bump.lua README. It has illustrations of collisions and the normal vectors they create.\n In game/engines/collision/ball_wall.ts:\nimport { Emits, Engine, Reads } from \u0026quot;encompass-ecs\u0026quot;; import { BoundingBoxComponent } from \u0026quot;game/components/bounding_box\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; import { VelocityComponent } from \u0026quot;game/components/velocity\u0026quot;; import { BallWallCollisionMessage } from \u0026quot;game/messages/collisions/ball_wall\u0026quot;; import { UpdatePositionMessage } from \u0026quot;game/messages/update_position\u0026quot;; import { UpdateVelocityMessage } from \u0026quot;game/messages/update_velocity\u0026quot;; @Reads(BallWallCollisionMessage) @Emits(UpdatePositionMessage, UpdateVelocityMessage) export class BallWallCollisionEngine extends Engine { public update() { for (const message of this.read_messages(BallWallCollisionMessage).values()) { const ball_position = message.ball_entity.get_component(PositionComponent); const ball_velocity = message.ball_entity.get_component(VelocityComponent); const ball_bounding_box = message.ball_entity.get_component(BoundingBoxComponent); const velocity_message = this.emit_component_message(UpdateVelocityMessage, ball_velocity); velocity_message.x_delta = 2 * message.normal.x * Math.abs(ball_velocity.x); velocity_message.y_delta = 2 * message.normal.y * Math.abs(ball_velocity.y); // calculate bounce, remembering to re-transform coordinates to origin space const y_distance = Math.abs(message.ball_new_y - (message.touch.y + ball_bounding_box.height * 0.5)); const x_distance = Math.abs(message.ball_new_x - (message.touch.x + ball_bounding_box.width * 0.5)); const position_message = this.emit_component_message(UpdatePositionMessage, ball_position); position_message.x_delta = 2 * message.normal.x * x_distance; position_message.y_delta = 2 * message.normal.y * y_distance; } } }  Notice that we also want to update the velocity when the ball bounces. Let\u0026rsquo;s create that UpdateVelocity behavior.\nIn game/messages/update_velocity.ts:\nimport { ComponentMessage, Message } from \u0026quot;encompass-ecs\u0026quot;; import { VelocityComponent } from \u0026quot;game/components/velocity\u0026quot;; export class UpdateVelocityMessage extends Message implements ComponentMessage { public component: Readonly\u0026lt;VelocityComponent\u0026gt;; public x_delta: number; public y_delta: number; }  In game/engines/update_velocity.ts:\nimport { ComponentModifier, Mutates, Reads } from \u0026quot;encompass-ecs\u0026quot;; import { VelocityComponent } from \u0026quot;game/components/velocity\u0026quot;; import { UpdateVelocityMessage } from \u0026quot;game/messages/update_velocity\u0026quot;; import { GCOptimizedSet } from \u0026quot;encompass-gc-optimized-collections\u0026quot;; @Reads(UpdateVelocityMessage) @Mutates(VelocityComponent) export class UpdateVelocityEngine extends ComponentModifier { public component_message_type = UpdateVelocityMessage; public modify(component: VelocityComponent, messages: GCOptimizedSet\u0026lt;UpdateVelocityMessage\u0026gt;) { for (const message of messages.entries()) { component.x += message.x_delta; component.y += message.y_delta; } } }  Our BallPaddleCollisionEngine will behave the exact same way. Why don\u0026rsquo;t you try to fill it in yourself?\nFinally, we want to make sure our paddles don\u0026rsquo;t go past the game boundary.\nimport { Emits, Engine, Reads } from \u0026quot;encompass-ecs\u0026quot;; import { BoundingBoxComponent } from \u0026quot;game/components/bounding_box\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; import { PaddleWallCollisionMessage } from \u0026quot;game/messages/collisions/paddle_wall\u0026quot;; import { UpdatePositionMessage } from \u0026quot;game/messages/update_position\u0026quot;; @Reads(PaddleWallCollisionMessage) @Emits(UpdatePositionMessage) export class PaddleWallCollisionEngine extends Engine { public update() { for (const message of this.read_messages(PaddleWallCollisionMessage).values()) { const paddle_position = message.paddle_entity.get_component(PositionComponent); const paddle_bounding_box = message.paddle_entity.get_component(BoundingBoxComponent); const x_distance = Math.abs(message.paddle_new_x - (message.touch.x + paddle_bounding_box.width * 0.5)); const y_distance = Math.abs(message.paddle_new_y - (message.touch.y + paddle_bounding_box.height * 0.5)); const position_message = this.emit_component_message(UpdatePositionMessage, paddle_position); position_message.x_delta = message.normal.x * x_distance; position_message.y_delta = message.normal.y * y_distance; } } }  That\u0026rsquo;s it for defining our collision behavior!\n"
},
{
	"uri": "/pong/ball/bouncing/spawners/",
	"title": "Spawners",
	"tags": [],
	"description": "",
	"content": " Our Entities are getting a bit more complex now with the addition of BoundingBoxComponents and CollisionTypeComponents.\nI think we should create Spawners for each of our game entities.\nThis will be pretty straightforward. Just decide which parameters we need to create our entities, and add the proper components with those parameters.\nBall In game/messages/ball_spawn.ts:\nimport { Message } from \u0026quot;encompass-ecs\u0026quot;; export class BallSpawnMessage extends Message { public x: number; public y: number; public size: number; public x_velocity: number; public y_velocity: number; }  In game/engines/spawners/ball.ts:\nimport { Reads, Spawner } from \u0026quot;encompass-ecs\u0026quot;; import { BoundingBoxComponent } from \u0026quot;game/components/bounding_box\u0026quot;; import { CanvasComponent } from \u0026quot;game/components/canvas\u0026quot;; import { CollisionType, CollisionTypesComponent } from \u0026quot;game/components/collision_types\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; import { VelocityComponent } from \u0026quot;game/components/velocity\u0026quot;; import { BallSpawnMessage } from \u0026quot;game/messages/ball_spawn\u0026quot;; import { World } from \u0026quot;lua-lib/bump\u0026quot;; @Reads(BallSpawnMessage) export class BallSpawner extends Spawner { public collision_world: World; public initialize(collision_world: World) { this.collision_world = collision_world; } public spawn(message: BallSpawnMessage) { const ball_entity = this.create_entity(); const ball_position_component = ball_entity.add_component(PositionComponent); ball_position_component.x = message.x; ball_position_component.y = message.y; const ball_canvas = love.graphics.newCanvas(message.size, message.size); love.graphics.setCanvas(ball_canvas); love.graphics.setBlendMode(\u0026quot;alpha\u0026quot;); love.graphics.setColor(1, 1, 1, 1); love.graphics.rectangle(\u0026quot;fill\u0026quot;, 0, 0, message.size, message.size); love.graphics.setCanvas(); const ball_canvas_component = ball_entity.add_component(CanvasComponent); ball_canvas_component.canvas = ball_canvas; ball_canvas_component.x_scale = 1; ball_canvas_component.y_scale = 1; const velocity_component = ball_entity.add_component(VelocityComponent); velocity_component.x = message.x_velocity; velocity_component.y = message.y_velocity; const boundaries_component = ball_entity.add_component(BoundingBoxComponent); boundaries_component.width = message.size; boundaries_component.height = message.size; const collision_types_component = ball_entity.add_component(CollisionTypesComponent); collision_types_component.collision_types = [ CollisionType.ball ]; this.collision_world.add(ball_entity, message.x, message.y, message.size, message.size); } }  Game Boundary In game/messages/game_boundary_spawn.ts:\nimport { Message } from \u0026quot;encompass-ecs\u0026quot;; export class GameBoundarySpawnMessage extends Message { public x: number; public y: number; public width: number; public height: number; }  In game/spawners/game_boundary.ts:\nimport { Reads, Spawner } from \u0026quot;encompass-ecs\u0026quot;; import { BoundingBoxComponent } from \u0026quot;game/components/bounding_box\u0026quot;; import { CollisionType, CollisionTypesComponent } from \u0026quot;game/components/collision_types\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; import { GameBoundarySpawnMessage } from \u0026quot;game/messages/game_boundary_spawn\u0026quot;; import { World } from \u0026quot;lua-lib/bump\u0026quot;; @Reads(GameBoundarySpawnMessage) export class GameBoundarySpawner extends Spawner { private collision_world: World; public initialize(collision_world: World) { this.collision_world = collision_world; } public spawn(message: GameBoundarySpawnMessage) { const entity = this.create_entity(); const boundaries = entity.add_component(BoundingBoxComponent); boundaries.width = message.width; boundaries.height = message.height; const position = entity.add_component(PositionComponent); position.x = message.x; position.y = message.y; const collision_types_component = entity.add_component(CollisionTypesComponent); collision_types_component.collision_types = [ CollisionType.wall ]; this.collision_world.add( entity, message.x - message.width * 0.5, message.y - message.height * 0.5, message.width, message.height ); } }  Paddle In game/messages/paddle_spawn.ts:\nimport { Message } from \u0026quot;encompass-ecs\u0026quot;; export class PaddleSpawnMessage extends Message { public x: number; public y: number; public width: number; public height: number; public move_speed: number; }  In game/spawners/paddle.ts:\nimport { Reads, Spawner } from \u0026quot;encompass-ecs\u0026quot;; import { BoundingBoxComponent } from \u0026quot;game/components/bounding_box\u0026quot;; import { CanvasComponent } from \u0026quot;game/components/canvas\u0026quot;; import { CollisionType, CollisionTypesComponent } from \u0026quot;game/components/collision_types\u0026quot;; import { PaddleMoveSpeedComponent } from \u0026quot;game/components/paddle_move_speed\u0026quot;; import { PlayerOneComponent } from \u0026quot;game/components/player_one\u0026quot;; import { PositionComponent } from \u0026quot;game/components/position\u0026quot;; import { PaddleSpawnMessage } from \u0026quot;game/messages/paddle_spawn\u0026quot;; import { World } from \u0026quot;lua-lib/bump\u0026quot;; @Reads(PaddleSpawnMessage) export class PaddleSpawner extends Spawner { private collision_world: World; public initialize(collision_world: World) { this.collision_world = collision_world; } protected spawn(message: PaddleSpawnMessage) { const paddle_entity = this.create_entity(); paddle_entity.add_component(PlayerOneComponent); const width = message.width; const height = message.height; const paddle_canvas = love.graphics.newCanvas(width, height); love.graphics.setCanvas(paddle_canvas); love.graphics.setBlendMode(\u0026quot;alpha\u0026quot;); love.graphics.setColor(1, 1, 1, 1); love.graphics.rectangle(\u0026quot;fill\u0026quot;, 0, 0, width, height); love.graphics.setCanvas(); const canvas_component = paddle_entity.add_component(CanvasComponent); canvas_component.canvas = paddle_canvas; canvas_component.x_scale = 1; canvas_component.y_scale = 1; const position_component = paddle_entity.add_component(PositionComponent); position_component.x = message.x; position_component.y = message.y; const move_speed_component = paddle_entity.add_component(PaddleMoveSpeedComponent); move_speed_component.y = message.move_speed; const paddle_boundaries = paddle_entity.add_component(BoundingBoxComponent); paddle_boundaries.width = width; paddle_boundaries.height = height; const collision_types_component = paddle_entity.add_component(CollisionTypesComponent); collision_types_component.collision_types = [ CollisionType.paddle ]; this.collision_world.add( paddle_entity, message.x - width * 0.5, message.y - height * 0.5, width, height ); } }  "
},
{
	"uri": "/pong/scoring/",
	"title": "Scoring",
	"tags": [],
	"description": "",
	"content": "Now we\u0026rsquo;re getting into the meat of the game.\nIn Pong, your opponent scores a point by getting the ball behind your paddle. There\u0026rsquo;s a few things we need to sort out here.\n The ball needs to detect collision with the goals. The ball needs to disappear for a while when a goal is scored. The ball position and velocity needs to be reset on a \u0026ldquo;serve\u0026rdquo;. The score of each player needs to be tracked.  Here\u0026rsquo;s what I\u0026rsquo;m thinking: first let\u0026rsquo;s sort out collision detection with the goal and resetting the ball. Then we can set up a scoring mechanism.\n"
},
{
	"uri": "/pong/ball/bouncing/putting_it_together/",
	"title": "Putting It All Together",
	"tags": [],
	"description": "",
	"content": "Finally, we need to set up our initial game state with our spawn messages, and make sure we added and initialized all of our required Engines.\nOur load method in game/game.ts should look something like this:\npublic load() { this.canvas = love.graphics.newCanvas(); const collision_world = CollisionWorld.newWorld(32); const world_builder = new WorldBuilder(); // ADD YOUR ENGINES HERE... world_builder.add_engine(BallSpawner).initialize(collision_world); world_builder.add_engine(GameBoundarySpawner).initialize(collision_world); world_builder.add_engine(PaddleSpawner).initialize(collision_world); world_builder.add_engine(InputEngine); world_builder.add_engine(PaddleMovementEngine); world_builder.add_engine(MotionEngine); world_builder.add_engine(VelocityEngine); world_builder.add_engine(CollisionCheckEngine).initialize(collision_world); world_builder.add_engine(CollisionDispatchEngine); world_builder.add_engine(BallWallCollisionEngine); world_builder.add_engine(BallPaddleCollisionEngine); world_builder.add_engine(UpdatePositionEngine); world_builder.add_engine(UpdateVelocityEngine); // ADD YOUR RENDERERS HERE... world_builder.add_renderer(CanvasRenderer); // ADD YOUR STARTING ENTITIES HERE... const play_area_width = 1280; const play_area_height = 720; const boundary_width = 30; const paddle_width = 20; const paddle_height = 120; const paddle_spacing = 40; const paddle_speed = 400; const ball_size = 16; const paddle_spawn_message = world_builder.emit_message(PaddleSpawnMessage); paddle_spawn_message.x = paddle_spacing; paddle_spawn_message.y = play_area_height * 0.5; paddle_spawn_message.width = paddle_width; paddle_spawn_message.height = paddle_height; paddle_spawn_message.move_speed = paddle_speed; const ball_spawn_message = world_builder.emit_message(BallSpawnMessage); ball_spawn_message.x = play_area_width * 0.5; ball_spawn_message.y = play_area_height * 0.5; ball_spawn_message.size = ball_size; ball_spawn_message.x_velocity = 200; ball_spawn_message.y_velocity = -400; const top_wall_spawn_message = world_builder.emit_message(GameBoundarySpawnMessage); top_wall_spawn_message.x = play_area_width * 0.5; top_wall_spawn_message.y = -boundary_width * 0.5; top_wall_spawn_message.width = play_area_width; top_wall_spawn_message.height = boundary_width; const right_wall_spawn_message = world_builder.emit_message(GameBoundarySpawnMessage); right_wall_spawn_message.x = play_area_width + boundary_width * 0.5; right_wall_spawn_message.y = play_area_height * 0.5; right_wall_spawn_message.width = boundary_width; right_wall_spawn_message.height = play_area_height; const bottom_wall_spawn_message = world_builder.emit_message(GameBoundarySpawnMessage); bottom_wall_spawn_message.x = play_area_width * 0.5; bottom_wall_spawn_message.y = boundary_width * 0.5 + play_area_height; bottom_wall_spawn_message.width = play_area_width; bottom_wall_spawn_message.height = boundary_width; const left_wall_spawn_message = world_builder.emit_message(GameBoundarySpawnMessage); left_wall_spawn_message.x = -boundary_width * 0.5; left_wall_spawn_message.y = play_area_height * 0.5; left_wall_spawn_message.width = boundary_width; left_wall_spawn_message.height = play_area_height; this.world = world_builder.build(); }  Let\u0026rsquo;s try it!\nnpm run love   All our hard work paid off. Look at that! chef kiss\n"
},
{
	"uri": "/pong/polish/",
	"title": "Finishing Touches",
	"tags": [],
	"description": "",
	"content": "At this point, all of the basic gameplay systems and visuals are in our game. Nice! Now we want to make it actually feel like Pong. This is a really good place to be, because our nice clean architecture makes it easy to tweak values until the game feels right.\n"
},
{
	"uri": "/pong/conclusion/",
	"title": "Conclusion",
	"tags": [],
	"description": "",
	"content": "We have our game loop but there\u0026rsquo;s still ways we could improve our game.\nThe gameplay is pretty basic right now. We could probably speed it up. Mouse controls would probably feel good. Maybe you could add a human vs human mode.\nBut you could go even crazier if you wanted. Why not throw a glow shader on it. Add a four player mode. Or maybe, fuck Pong, you want to make your own game instead of some glorified stuffy 70s arcade game. Go for it! You\u0026rsquo;re the game designer and it\u0026rsquo;s your world.\nThis tutorial should have given you a pretty good idea of how to build your game simulation in Encompass. If you have suggestions for how the tutorial could be made better, or you have questions about Encompass, or you want to get feedback from other Encompass developers, why not join our Discord server?\n"
},
{
	"uri": "/",
	"title": "Encompass",
	"tags": [],
	"description": "",
	"content": " Encompass Encompass is a powerful engine-agnostic framework to help you code games, or other kinds of simulations.\nObject-oriented code is messy and rapidly becomes unmaintainable.\nEncompass lets you write clean, de-coupled code so you can spend more time on your game design and less time fixing bugs.\nEncompass is currently available with a TypeScript implementation that fully supports transpilation to Javascript and Lua.\nA C# implementation is in early alpha stage and available as a NuGet package.\nIf you are here to learn how to use Encompass and don\u0026rsquo;t care about the justifications for it, or you\u0026rsquo;ve never made a game before, I recommend skipping ahead to Chapter 2.\nAnd if you have questions or would like to chat about the project, why not join us on our Discord server?\n"
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]